// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: internal.proto

package protocol

import (
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type Op int32

const (
	Op_CREATE_STREAM       Op = 0
	Op_SHRINK_ISR          Op = 1
	Op_REPORT_LEADER       Op = 2
	Op_CHANGE_LEADER       Op = 3
	Op_EXPAND_ISR          Op = 4
	Op_DELETE_STREAM       Op = 5
	Op_PAUSE_STREAM        Op = 6
	Op_RESUME_STREAM       Op = 7
	Op_PUBLISH_ACTIVITY    Op = 8
	Op_SET_STREAM_READONLY Op = 9
)

var Op_name = map[int32]string{
	0: "CREATE_STREAM",
	1: "SHRINK_ISR",
	2: "REPORT_LEADER",
	3: "CHANGE_LEADER",
	4: "EXPAND_ISR",
	5: "DELETE_STREAM",
	6: "PAUSE_STREAM",
	7: "RESUME_STREAM",
	8: "PUBLISH_ACTIVITY",
	9: "SET_STREAM_READONLY",
}

var Op_value = map[string]int32{
	"CREATE_STREAM":       0,
	"SHRINK_ISR":          1,
	"REPORT_LEADER":       2,
	"CHANGE_LEADER":       3,
	"EXPAND_ISR":          4,
	"DELETE_STREAM":       5,
	"PAUSE_STREAM":        6,
	"RESUME_STREAM":       7,
	"PUBLISH_ACTIVITY":    8,
	"SET_STREAM_READONLY": 9,
}

func (x Op) String() string {
	return proto.EnumName(Op_name, int32(x))
}

func (Op) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_41f4a519b878ee3b, []int{0}
}

type ServerState struct {
	ServerID             string   `protobuf:"bytes,1,opt,name=serverID,proto3" json:"serverID,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ServerState) Reset()         { *m = ServerState{} }
func (m *ServerState) String() string { return proto.CompactTextString(m) }
func (*ServerState) ProtoMessage()    {}
func (*ServerState) Descriptor() ([]byte, []int) {
	return fileDescriptor_41f4a519b878ee3b, []int{0}
}
func (m *ServerState) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ServerState) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ServerState.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ServerState) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ServerState.Merge(m, src)
}
func (m *ServerState) XXX_Size() int {
	return m.Size()
}
func (m *ServerState) XXX_DiscardUnknown() {
	xxx_messageInfo_ServerState.DiscardUnknown(m)
}

var xxx_messageInfo_ServerState proto.InternalMessageInfo

func (m *ServerState) GetServerID() string {
	if m != nil {
		return m.ServerID
	}
	return ""
}

type RaftLog struct {
	Op                   Op                   `protobuf:"varint,1,opt,name=op,proto3,enum=protocol.Op" json:"op,omitempty"`
	CreateStreamOp       *CreateStreamOp      `protobuf:"bytes,2,opt,name=createStreamOp,proto3" json:"createStreamOp,omitempty"`
	ShrinkISROp          *ShrinkISROp         `protobuf:"bytes,3,opt,name=shrinkISROp,proto3" json:"shrinkISROp,omitempty"`
	ChangeLeaderOp       *ChangeLeaderOp      `protobuf:"bytes,4,opt,name=changeLeaderOp,proto3" json:"changeLeaderOp,omitempty"`
	ExpandISROp          *ExpandISROp         `protobuf:"bytes,5,opt,name=expandISROp,proto3" json:"expandISROp,omitempty"`
	DeleteStreamOp       *DeleteStreamOp      `protobuf:"bytes,6,opt,name=deleteStreamOp,proto3" json:"deleteStreamOp,omitempty"`
	PauseStreamOp        *PauseStreamOp       `protobuf:"bytes,7,opt,name=pauseStreamOp,proto3" json:"pauseStreamOp,omitempty"`
	ResumeStreamOp       *ResumeStreamOp      `protobuf:"bytes,8,opt,name=resumeStreamOp,proto3" json:"resumeStreamOp,omitempty"`
	PublishActivityOp    *PublishActivityOp   `protobuf:"bytes,9,opt,name=publishActivityOp,proto3" json:"publishActivityOp,omitempty"`
	SetStreamReadonlyOp  *SetStreamReadonlyOp `protobuf:"bytes,10,opt,name=setStreamReadonlyOp,proto3" json:"setStreamReadonlyOp,omitempty"`
	XXX_NoUnkeyedLiteral struct{}             `json:"-"`
	XXX_unrecognized     []byte               `json:"-"`
	XXX_sizecache        int32                `json:"-"`
}

func (m *RaftLog) Reset()         { *m = RaftLog{} }
func (m *RaftLog) String() string { return proto.CompactTextString(m) }
func (*RaftLog) ProtoMessage()    {}
func (*RaftLog) Descriptor() ([]byte, []int) {
	return fileDescriptor_41f4a519b878ee3b, []int{1}
}
func (m *RaftLog) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RaftLog) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RaftLog.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RaftLog) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RaftLog.Merge(m, src)
}
func (m *RaftLog) XXX_Size() int {
	return m.Size()
}
func (m *RaftLog) XXX_DiscardUnknown() {
	xxx_messageInfo_RaftLog.DiscardUnknown(m)
}

var xxx_messageInfo_RaftLog proto.InternalMessageInfo

func (m *RaftLog) GetOp() Op {
	if m != nil {
		return m.Op
	}
	return Op_CREATE_STREAM
}

func (m *RaftLog) GetCreateStreamOp() *CreateStreamOp {
	if m != nil {
		return m.CreateStreamOp
	}
	return nil
}

func (m *RaftLog) GetShrinkISROp() *ShrinkISROp {
	if m != nil {
		return m.ShrinkISROp
	}
	return nil
}

func (m *RaftLog) GetChangeLeaderOp() *ChangeLeaderOp {
	if m != nil {
		return m.ChangeLeaderOp
	}
	return nil
}

func (m *RaftLog) GetExpandISROp() *ExpandISROp {
	if m != nil {
		return m.ExpandISROp
	}
	return nil
}

func (m *RaftLog) GetDeleteStreamOp() *DeleteStreamOp {
	if m != nil {
		return m.DeleteStreamOp
	}
	return nil
}

func (m *RaftLog) GetPauseStreamOp() *PauseStreamOp {
	if m != nil {
		return m.PauseStreamOp
	}
	return nil
}

func (m *RaftLog) GetResumeStreamOp() *ResumeStreamOp {
	if m != nil {
		return m.ResumeStreamOp
	}
	return nil
}

func (m *RaftLog) GetPublishActivityOp() *PublishActivityOp {
	if m != nil {
		return m.PublishActivityOp
	}
	return nil
}

func (m *RaftLog) GetSetStreamReadonlyOp() *SetStreamReadonlyOp {
	if m != nil {
		return m.SetStreamReadonlyOp
	}
	return nil
}

type CreateStreamOp struct {
	Stream               *Stream  `protobuf:"bytes,1,opt,name=stream,proto3" json:"stream,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CreateStreamOp) Reset()         { *m = CreateStreamOp{} }
func (m *CreateStreamOp) String() string { return proto.CompactTextString(m) }
func (*CreateStreamOp) ProtoMessage()    {}
func (*CreateStreamOp) Descriptor() ([]byte, []int) {
	return fileDescriptor_41f4a519b878ee3b, []int{2}
}
func (m *CreateStreamOp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CreateStreamOp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CreateStreamOp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CreateStreamOp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CreateStreamOp.Merge(m, src)
}
func (m *CreateStreamOp) XXX_Size() int {
	return m.Size()
}
func (m *CreateStreamOp) XXX_DiscardUnknown() {
	xxx_messageInfo_CreateStreamOp.DiscardUnknown(m)
}

var xxx_messageInfo_CreateStreamOp proto.InternalMessageInfo

func (m *CreateStreamOp) GetStream() *Stream {
	if m != nil {
		return m.Stream
	}
	return nil
}

type ShrinkISROp struct {
	Stream               string   `protobuf:"bytes,1,opt,name=stream,proto3" json:"stream,omitempty"`
	Partition            int32    `protobuf:"varint,2,opt,name=partition,proto3" json:"partition,omitempty"`
	ReplicaToRemove      string   `protobuf:"bytes,3,opt,name=replicaToRemove,proto3" json:"replicaToRemove,omitempty"`
	Leader               string   `protobuf:"bytes,4,opt,name=leader,proto3" json:"leader,omitempty"`
	LeaderEpoch          uint64   `protobuf:"varint,5,opt,name=leaderEpoch,proto3" json:"leaderEpoch,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ShrinkISROp) Reset()         { *m = ShrinkISROp{} }
func (m *ShrinkISROp) String() string { return proto.CompactTextString(m) }
func (*ShrinkISROp) ProtoMessage()    {}
func (*ShrinkISROp) Descriptor() ([]byte, []int) {
	return fileDescriptor_41f4a519b878ee3b, []int{3}
}
func (m *ShrinkISROp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ShrinkISROp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ShrinkISROp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ShrinkISROp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ShrinkISROp.Merge(m, src)
}
func (m *ShrinkISROp) XXX_Size() int {
	return m.Size()
}
func (m *ShrinkISROp) XXX_DiscardUnknown() {
	xxx_messageInfo_ShrinkISROp.DiscardUnknown(m)
}

var xxx_messageInfo_ShrinkISROp proto.InternalMessageInfo

func (m *ShrinkISROp) GetStream() string {
	if m != nil {
		return m.Stream
	}
	return ""
}

func (m *ShrinkISROp) GetPartition() int32 {
	if m != nil {
		return m.Partition
	}
	return 0
}

func (m *ShrinkISROp) GetReplicaToRemove() string {
	if m != nil {
		return m.ReplicaToRemove
	}
	return ""
}

func (m *ShrinkISROp) GetLeader() string {
	if m != nil {
		return m.Leader
	}
	return ""
}

func (m *ShrinkISROp) GetLeaderEpoch() uint64 {
	if m != nil {
		return m.LeaderEpoch
	}
	return 0
}

type ExpandISROp struct {
	Stream               string   `protobuf:"bytes,1,opt,name=stream,proto3" json:"stream,omitempty"`
	Partition            int32    `protobuf:"varint,2,opt,name=partition,proto3" json:"partition,omitempty"`
	ReplicaToAdd         string   `protobuf:"bytes,3,opt,name=replicaToAdd,proto3" json:"replicaToAdd,omitempty"`
	Leader               string   `protobuf:"bytes,4,opt,name=leader,proto3" json:"leader,omitempty"`
	LeaderEpoch          uint64   `protobuf:"varint,5,opt,name=leaderEpoch,proto3" json:"leaderEpoch,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ExpandISROp) Reset()         { *m = ExpandISROp{} }
func (m *ExpandISROp) String() string { return proto.CompactTextString(m) }
func (*ExpandISROp) ProtoMessage()    {}
func (*ExpandISROp) Descriptor() ([]byte, []int) {
	return fileDescriptor_41f4a519b878ee3b, []int{4}
}
func (m *ExpandISROp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ExpandISROp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ExpandISROp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ExpandISROp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ExpandISROp.Merge(m, src)
}
func (m *ExpandISROp) XXX_Size() int {
	return m.Size()
}
func (m *ExpandISROp) XXX_DiscardUnknown() {
	xxx_messageInfo_ExpandISROp.DiscardUnknown(m)
}

var xxx_messageInfo_ExpandISROp proto.InternalMessageInfo

func (m *ExpandISROp) GetStream() string {
	if m != nil {
		return m.Stream
	}
	return ""
}

func (m *ExpandISROp) GetPartition() int32 {
	if m != nil {
		return m.Partition
	}
	return 0
}

func (m *ExpandISROp) GetReplicaToAdd() string {
	if m != nil {
		return m.ReplicaToAdd
	}
	return ""
}

func (m *ExpandISROp) GetLeader() string {
	if m != nil {
		return m.Leader
	}
	return ""
}

func (m *ExpandISROp) GetLeaderEpoch() uint64 {
	if m != nil {
		return m.LeaderEpoch
	}
	return 0
}

type DeleteStreamOp struct {
	Stream               string   `protobuf:"bytes,1,opt,name=stream,proto3" json:"stream,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DeleteStreamOp) Reset()         { *m = DeleteStreamOp{} }
func (m *DeleteStreamOp) String() string { return proto.CompactTextString(m) }
func (*DeleteStreamOp) ProtoMessage()    {}
func (*DeleteStreamOp) Descriptor() ([]byte, []int) {
	return fileDescriptor_41f4a519b878ee3b, []int{5}
}
func (m *DeleteStreamOp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeleteStreamOp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DeleteStreamOp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DeleteStreamOp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeleteStreamOp.Merge(m, src)
}
func (m *DeleteStreamOp) XXX_Size() int {
	return m.Size()
}
func (m *DeleteStreamOp) XXX_DiscardUnknown() {
	xxx_messageInfo_DeleteStreamOp.DiscardUnknown(m)
}

var xxx_messageInfo_DeleteStreamOp proto.InternalMessageInfo

func (m *DeleteStreamOp) GetStream() string {
	if m != nil {
		return m.Stream
	}
	return ""
}

type PauseStreamOp struct {
	Stream               string   `protobuf:"bytes,1,opt,name=stream,proto3" json:"stream,omitempty"`
	Partitions           []int32  `protobuf:"varint,2,rep,packed,name=partitions,proto3" json:"partitions,omitempty"`
	ResumeAll            bool     `protobuf:"varint,3,opt,name=resumeAll,proto3" json:"resumeAll,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PauseStreamOp) Reset()         { *m = PauseStreamOp{} }
func (m *PauseStreamOp) String() string { return proto.CompactTextString(m) }
func (*PauseStreamOp) ProtoMessage()    {}
func (*PauseStreamOp) Descriptor() ([]byte, []int) {
	return fileDescriptor_41f4a519b878ee3b, []int{6}
}
func (m *PauseStreamOp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PauseStreamOp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PauseStreamOp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PauseStreamOp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PauseStreamOp.Merge(m, src)
}
func (m *PauseStreamOp) XXX_Size() int {
	return m.Size()
}
func (m *PauseStreamOp) XXX_DiscardUnknown() {
	xxx_messageInfo_PauseStreamOp.DiscardUnknown(m)
}

var xxx_messageInfo_PauseStreamOp proto.InternalMessageInfo

func (m *PauseStreamOp) GetStream() string {
	if m != nil {
		return m.Stream
	}
	return ""
}

func (m *PauseStreamOp) GetPartitions() []int32 {
	if m != nil {
		return m.Partitions
	}
	return nil
}

func (m *PauseStreamOp) GetResumeAll() bool {
	if m != nil {
		return m.ResumeAll
	}
	return false
}

type ResumeStreamOp struct {
	Stream               string   `protobuf:"bytes,1,opt,name=stream,proto3" json:"stream,omitempty"`
	Partitions           []int32  `protobuf:"varint,2,rep,packed,name=partitions,proto3" json:"partitions,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ResumeStreamOp) Reset()         { *m = ResumeStreamOp{} }
func (m *ResumeStreamOp) String() string { return proto.CompactTextString(m) }
func (*ResumeStreamOp) ProtoMessage()    {}
func (*ResumeStreamOp) Descriptor() ([]byte, []int) {
	return fileDescriptor_41f4a519b878ee3b, []int{7}
}
func (m *ResumeStreamOp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ResumeStreamOp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ResumeStreamOp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ResumeStreamOp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ResumeStreamOp.Merge(m, src)
}
func (m *ResumeStreamOp) XXX_Size() int {
	return m.Size()
}
func (m *ResumeStreamOp) XXX_DiscardUnknown() {
	xxx_messageInfo_ResumeStreamOp.DiscardUnknown(m)
}

var xxx_messageInfo_ResumeStreamOp proto.InternalMessageInfo

func (m *ResumeStreamOp) GetStream() string {
	if m != nil {
		return m.Stream
	}
	return ""
}

func (m *ResumeStreamOp) GetPartitions() []int32 {
	if m != nil {
		return m.Partitions
	}
	return nil
}

type ReportLeaderOp struct {
	Stream               string   `protobuf:"bytes,1,opt,name=stream,proto3" json:"stream,omitempty"`
	Partition            int32    `protobuf:"varint,2,opt,name=partition,proto3" json:"partition,omitempty"`
	Replica              string   `protobuf:"bytes,3,opt,name=replica,proto3" json:"replica,omitempty"`
	Leader               string   `protobuf:"bytes,4,opt,name=leader,proto3" json:"leader,omitempty"`
	LeaderEpoch          uint64   `protobuf:"varint,5,opt,name=leaderEpoch,proto3" json:"leaderEpoch,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ReportLeaderOp) Reset()         { *m = ReportLeaderOp{} }
func (m *ReportLeaderOp) String() string { return proto.CompactTextString(m) }
func (*ReportLeaderOp) ProtoMessage()    {}
func (*ReportLeaderOp) Descriptor() ([]byte, []int) {
	return fileDescriptor_41f4a519b878ee3b, []int{8}
}
func (m *ReportLeaderOp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ReportLeaderOp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ReportLeaderOp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ReportLeaderOp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReportLeaderOp.Merge(m, src)
}
func (m *ReportLeaderOp) XXX_Size() int {
	return m.Size()
}
func (m *ReportLeaderOp) XXX_DiscardUnknown() {
	xxx_messageInfo_ReportLeaderOp.DiscardUnknown(m)
}

var xxx_messageInfo_ReportLeaderOp proto.InternalMessageInfo

func (m *ReportLeaderOp) GetStream() string {
	if m != nil {
		return m.Stream
	}
	return ""
}

func (m *ReportLeaderOp) GetPartition() int32 {
	if m != nil {
		return m.Partition
	}
	return 0
}

func (m *ReportLeaderOp) GetReplica() string {
	if m != nil {
		return m.Replica
	}
	return ""
}

func (m *ReportLeaderOp) GetLeader() string {
	if m != nil {
		return m.Leader
	}
	return ""
}

func (m *ReportLeaderOp) GetLeaderEpoch() uint64 {
	if m != nil {
		return m.LeaderEpoch
	}
	return 0
}

type ChangeLeaderOp struct {
	Stream               string   `protobuf:"bytes,1,opt,name=stream,proto3" json:"stream,omitempty"`
	Partition            int32    `protobuf:"varint,2,opt,name=partition,proto3" json:"partition,omitempty"`
	Leader               string   `protobuf:"bytes,3,opt,name=leader,proto3" json:"leader,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ChangeLeaderOp) Reset()         { *m = ChangeLeaderOp{} }
func (m *ChangeLeaderOp) String() string { return proto.CompactTextString(m) }
func (*ChangeLeaderOp) ProtoMessage()    {}
func (*ChangeLeaderOp) Descriptor() ([]byte, []int) {
	return fileDescriptor_41f4a519b878ee3b, []int{9}
}
func (m *ChangeLeaderOp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ChangeLeaderOp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ChangeLeaderOp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ChangeLeaderOp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ChangeLeaderOp.Merge(m, src)
}
func (m *ChangeLeaderOp) XXX_Size() int {
	return m.Size()
}
func (m *ChangeLeaderOp) XXX_DiscardUnknown() {
	xxx_messageInfo_ChangeLeaderOp.DiscardUnknown(m)
}

var xxx_messageInfo_ChangeLeaderOp proto.InternalMessageInfo

func (m *ChangeLeaderOp) GetStream() string {
	if m != nil {
		return m.Stream
	}
	return ""
}

func (m *ChangeLeaderOp) GetPartition() int32 {
	if m != nil {
		return m.Partition
	}
	return 0
}

func (m *ChangeLeaderOp) GetLeader() string {
	if m != nil {
		return m.Leader
	}
	return ""
}

type PublishActivityOp struct {
	RaftIndex            uint64   `protobuf:"varint,1,opt,name=raftIndex,proto3" json:"raftIndex,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PublishActivityOp) Reset()         { *m = PublishActivityOp{} }
func (m *PublishActivityOp) String() string { return proto.CompactTextString(m) }
func (*PublishActivityOp) ProtoMessage()    {}
func (*PublishActivityOp) Descriptor() ([]byte, []int) {
	return fileDescriptor_41f4a519b878ee3b, []int{10}
}
func (m *PublishActivityOp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PublishActivityOp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PublishActivityOp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PublishActivityOp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PublishActivityOp.Merge(m, src)
}
func (m *PublishActivityOp) XXX_Size() int {
	return m.Size()
}
func (m *PublishActivityOp) XXX_DiscardUnknown() {
	xxx_messageInfo_PublishActivityOp.DiscardUnknown(m)
}

var xxx_messageInfo_PublishActivityOp proto.InternalMessageInfo

func (m *PublishActivityOp) GetRaftIndex() uint64 {
	if m != nil {
		return m.RaftIndex
	}
	return 0
}

type SetStreamReadonlyOp struct {
	Stream               string   `protobuf:"bytes,1,opt,name=stream,proto3" json:"stream,omitempty"`
	Partitions           []int32  `protobuf:"varint,2,rep,packed,name=partitions,proto3" json:"partitions,omitempty"`
	Readonly             bool     `protobuf:"varint,3,opt,name=readonly,proto3" json:"readonly,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SetStreamReadonlyOp) Reset()         { *m = SetStreamReadonlyOp{} }
func (m *SetStreamReadonlyOp) String() string { return proto.CompactTextString(m) }
func (*SetStreamReadonlyOp) ProtoMessage()    {}
func (*SetStreamReadonlyOp) Descriptor() ([]byte, []int) {
	return fileDescriptor_41f4a519b878ee3b, []int{11}
}
func (m *SetStreamReadonlyOp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SetStreamReadonlyOp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SetStreamReadonlyOp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SetStreamReadonlyOp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SetStreamReadonlyOp.Merge(m, src)
}
func (m *SetStreamReadonlyOp) XXX_Size() int {
	return m.Size()
}
func (m *SetStreamReadonlyOp) XXX_DiscardUnknown() {
	xxx_messageInfo_SetStreamReadonlyOp.DiscardUnknown(m)
}

var xxx_messageInfo_SetStreamReadonlyOp proto.InternalMessageInfo

func (m *SetStreamReadonlyOp) GetStream() string {
	if m != nil {
		return m.Stream
	}
	return ""
}

func (m *SetStreamReadonlyOp) GetPartitions() []int32 {
	if m != nil {
		return m.Partitions
	}
	return nil
}

func (m *SetStreamReadonlyOp) GetReadonly() bool {
	if m != nil {
		return m.Readonly
	}
	return false
}

type NullableInt64 struct {
	Value                int64    `protobuf:"varint,1,opt,name=value,proto3" json:"value,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *NullableInt64) Reset()         { *m = NullableInt64{} }
func (m *NullableInt64) String() string { return proto.CompactTextString(m) }
func (*NullableInt64) ProtoMessage()    {}
func (*NullableInt64) Descriptor() ([]byte, []int) {
	return fileDescriptor_41f4a519b878ee3b, []int{12}
}
func (m *NullableInt64) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NullableInt64) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NullableInt64.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NullableInt64) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NullableInt64.Merge(m, src)
}
func (m *NullableInt64) XXX_Size() int {
	return m.Size()
}
func (m *NullableInt64) XXX_DiscardUnknown() {
	xxx_messageInfo_NullableInt64.DiscardUnknown(m)
}

var xxx_messageInfo_NullableInt64 proto.InternalMessageInfo

func (m *NullableInt64) GetValue() int64 {
	if m != nil {
		return m.Value
	}
	return 0
}

type NullableInt32 struct {
	Value                int32    `protobuf:"varint,1,opt,name=value,proto3" json:"value,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *NullableInt32) Reset()         { *m = NullableInt32{} }
func (m *NullableInt32) String() string { return proto.CompactTextString(m) }
func (*NullableInt32) ProtoMessage()    {}
func (*NullableInt32) Descriptor() ([]byte, []int) {
	return fileDescriptor_41f4a519b878ee3b, []int{13}
}
func (m *NullableInt32) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NullableInt32) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NullableInt32.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NullableInt32) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NullableInt32.Merge(m, src)
}
func (m *NullableInt32) XXX_Size() int {
	return m.Size()
}
func (m *NullableInt32) XXX_DiscardUnknown() {
	xxx_messageInfo_NullableInt32.DiscardUnknown(m)
}

var xxx_messageInfo_NullableInt32 proto.InternalMessageInfo

func (m *NullableInt32) GetValue() int32 {
	if m != nil {
		return m.Value
	}
	return 0
}

type NullableBool struct {
	Value                bool     `protobuf:"varint,1,opt,name=value,proto3" json:"value,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *NullableBool) Reset()         { *m = NullableBool{} }
func (m *NullableBool) String() string { return proto.CompactTextString(m) }
func (*NullableBool) ProtoMessage()    {}
func (*NullableBool) Descriptor() ([]byte, []int) {
	return fileDescriptor_41f4a519b878ee3b, []int{14}
}
func (m *NullableBool) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NullableBool) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NullableBool.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NullableBool) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NullableBool.Merge(m, src)
}
func (m *NullableBool) XXX_Size() int {
	return m.Size()
}
func (m *NullableBool) XXX_DiscardUnknown() {
	xxx_messageInfo_NullableBool.DiscardUnknown(m)
}

var xxx_messageInfo_NullableBool proto.InternalMessageInfo

func (m *NullableBool) GetValue() bool {
	if m != nil {
		return m.Value
	}
	return false
}

type StreamConfig struct {
	RetentionMaxBytes             *NullableInt64 `protobuf:"bytes,1,opt,name=retentionMaxBytes,proto3" json:"retentionMaxBytes,omitempty"`
	RetentionMaxMessages          *NullableInt64 `protobuf:"bytes,2,opt,name=retentionMaxMessages,proto3" json:"retentionMaxMessages,omitempty"`
	RetentionMaxAge               *NullableInt64 `protobuf:"bytes,3,opt,name=retentionMaxAge,proto3" json:"retentionMaxAge,omitempty"`
	CleanerInterval               *NullableInt64 `protobuf:"bytes,4,opt,name=cleanerInterval,proto3" json:"cleanerInterval,omitempty"`
	SegmentMaxBytes               *NullableInt64 `protobuf:"bytes,5,opt,name=segmentMaxBytes,proto3" json:"segmentMaxBytes,omitempty"`
	SegmentMaxAge                 *NullableInt64 `protobuf:"bytes,6,opt,name=segmentMaxAge,proto3" json:"segmentMaxAge,omitempty"`
	CompactMaxGoroutines          *NullableInt32 `protobuf:"bytes,7,opt,name=compactMaxGoroutines,proto3" json:"compactMaxGoroutines,omitempty"`
	CompactEnabled                *NullableBool  `protobuf:"bytes,8,opt,name=compactEnabled,proto3" json:"compactEnabled,omitempty"`
	AutoPauseTime                 *NullableInt64 `protobuf:"bytes,9,opt,name=autoPauseTime,proto3" json:"autoPauseTime,omitempty"`
	AutoPauseDisableIfSubscribers *NullableBool  `protobuf:"bytes,10,opt,name=autoPauseDisableIfSubscribers,proto3" json:"autoPauseDisableIfSubscribers,omitempty"`
	MinIsr                        *NullableInt32 `protobuf:"bytes,11,opt,name=minIsr,proto3" json:"minIsr,omitempty"`
	OptimisticConcurrencyControl  *NullableBool  `protobuf:"bytes,12,opt,name=optimisticConcurrencyControl,proto3" json:"optimisticConcurrencyControl,omitempty"`
	XXX_NoUnkeyedLiteral          struct{}       `json:"-"`
	XXX_unrecognized              []byte         `json:"-"`
	XXX_sizecache                 int32          `json:"-"`
}

func (m *StreamConfig) Reset()         { *m = StreamConfig{} }
func (m *StreamConfig) String() string { return proto.CompactTextString(m) }
func (*StreamConfig) ProtoMessage()    {}
func (*StreamConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_41f4a519b878ee3b, []int{15}
}
func (m *StreamConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StreamConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StreamConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StreamConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StreamConfig.Merge(m, src)
}
func (m *StreamConfig) XXX_Size() int {
	return m.Size()
}
func (m *StreamConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_StreamConfig.DiscardUnknown(m)
}

var xxx_messageInfo_StreamConfig proto.InternalMessageInfo

func (m *StreamConfig) GetRetentionMaxBytes() *NullableInt64 {
	if m != nil {
		return m.RetentionMaxBytes
	}
	return nil
}

func (m *StreamConfig) GetRetentionMaxMessages() *NullableInt64 {
	if m != nil {
		return m.RetentionMaxMessages
	}
	return nil
}

func (m *StreamConfig) GetRetentionMaxAge() *NullableInt64 {
	if m != nil {
		return m.RetentionMaxAge
	}
	return nil
}

func (m *StreamConfig) GetCleanerInterval() *NullableInt64 {
	if m != nil {
		return m.CleanerInterval
	}
	return nil
}

func (m *StreamConfig) GetSegmentMaxBytes() *NullableInt64 {
	if m != nil {
		return m.SegmentMaxBytes
	}
	return nil
}

func (m *StreamConfig) GetSegmentMaxAge() *NullableInt64 {
	if m != nil {
		return m.SegmentMaxAge
	}
	return nil
}

func (m *StreamConfig) GetCompactMaxGoroutines() *NullableInt32 {
	if m != nil {
		return m.CompactMaxGoroutines
	}
	return nil
}

func (m *StreamConfig) GetCompactEnabled() *NullableBool {
	if m != nil {
		return m.CompactEnabled
	}
	return nil
}

func (m *StreamConfig) GetAutoPauseTime() *NullableInt64 {
	if m != nil {
		return m.AutoPauseTime
	}
	return nil
}

func (m *StreamConfig) GetAutoPauseDisableIfSubscribers() *NullableBool {
	if m != nil {
		return m.AutoPauseDisableIfSubscribers
	}
	return nil
}

func (m *StreamConfig) GetMinIsr() *NullableInt32 {
	if m != nil {
		return m.MinIsr
	}
	return nil
}

func (m *StreamConfig) GetOptimisticConcurrencyControl() *NullableBool {
	if m != nil {
		return m.OptimisticConcurrencyControl
	}
	return nil
}

type Stream struct {
	Name                 string        `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Subject              string        `protobuf:"bytes,2,opt,name=subject,proto3" json:"subject,omitempty"`
	Partitions           []*Partition  `protobuf:"bytes,3,rep,name=partitions,proto3" json:"partitions,omitempty"`
	Config               *StreamConfig `protobuf:"bytes,4,opt,name=config,proto3" json:"config,omitempty"`
	CreationTimestamp    int64         `protobuf:"varint,5,opt,name=creationTimestamp,proto3" json:"creationTimestamp,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *Stream) Reset()         { *m = Stream{} }
func (m *Stream) String() string { return proto.CompactTextString(m) }
func (*Stream) ProtoMessage()    {}
func (*Stream) Descriptor() ([]byte, []int) {
	return fileDescriptor_41f4a519b878ee3b, []int{16}
}
func (m *Stream) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Stream) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Stream.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Stream) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Stream.Merge(m, src)
}
func (m *Stream) XXX_Size() int {
	return m.Size()
}
func (m *Stream) XXX_DiscardUnknown() {
	xxx_messageInfo_Stream.DiscardUnknown(m)
}

var xxx_messageInfo_Stream proto.InternalMessageInfo

func (m *Stream) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Stream) GetSubject() string {
	if m != nil {
		return m.Subject
	}
	return ""
}

func (m *Stream) GetPartitions() []*Partition {
	if m != nil {
		return m.Partitions
	}
	return nil
}

func (m *Stream) GetConfig() *StreamConfig {
	if m != nil {
		return m.Config
	}
	return nil
}

func (m *Stream) GetCreationTimestamp() int64 {
	if m != nil {
		return m.CreationTimestamp
	}
	return 0
}

type Partition struct {
	Subject              string   `protobuf:"bytes,1,opt,name=subject,proto3" json:"subject,omitempty"`
	Stream               string   `protobuf:"bytes,2,opt,name=stream,proto3" json:"stream,omitempty"`
	Id                   int32    `protobuf:"varint,3,opt,name=id,proto3" json:"id,omitempty"`
	Group                string   `protobuf:"bytes,4,opt,name=group,proto3" json:"group,omitempty"`
	ReplicationFactor    int32    `protobuf:"varint,5,opt,name=replicationFactor,proto3" json:"replicationFactor,omitempty"`
	Replicas             []string `protobuf:"bytes,6,rep,name=replicas,proto3" json:"replicas,omitempty"`
	Leader               string   `protobuf:"bytes,7,opt,name=leader,proto3" json:"leader,omitempty"`
	Isr                  []string `protobuf:"bytes,8,rep,name=isr,proto3" json:"isr,omitempty"`
	LeaderEpoch          uint64   `protobuf:"varint,9,opt,name=leaderEpoch,proto3" json:"leaderEpoch,omitempty"`
	Epoch                uint64   `protobuf:"varint,10,opt,name=epoch,proto3" json:"epoch,omitempty"`
	Paused               bool     `protobuf:"varint,11,opt,name=paused,proto3" json:"paused,omitempty"`
	Readonly             bool     `protobuf:"varint,12,opt,name=readonly,proto3" json:"readonly,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Partition) Reset()         { *m = Partition{} }
func (m *Partition) String() string { return proto.CompactTextString(m) }
func (*Partition) ProtoMessage()    {}
func (*Partition) Descriptor() ([]byte, []int) {
	return fileDescriptor_41f4a519b878ee3b, []int{17}
}
func (m *Partition) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Partition) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Partition.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Partition) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Partition.Merge(m, src)
}
func (m *Partition) XXX_Size() int {
	return m.Size()
}
func (m *Partition) XXX_DiscardUnknown() {
	xxx_messageInfo_Partition.DiscardUnknown(m)
}

var xxx_messageInfo_Partition proto.InternalMessageInfo

func (m *Partition) GetSubject() string {
	if m != nil {
		return m.Subject
	}
	return ""
}

func (m *Partition) GetStream() string {
	if m != nil {
		return m.Stream
	}
	return ""
}

func (m *Partition) GetId() int32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *Partition) GetGroup() string {
	if m != nil {
		return m.Group
	}
	return ""
}

func (m *Partition) GetReplicationFactor() int32 {
	if m != nil {
		return m.ReplicationFactor
	}
	return 0
}

func (m *Partition) GetReplicas() []string {
	if m != nil {
		return m.Replicas
	}
	return nil
}

func (m *Partition) GetLeader() string {
	if m != nil {
		return m.Leader
	}
	return ""
}

func (m *Partition) GetIsr() []string {
	if m != nil {
		return m.Isr
	}
	return nil
}

func (m *Partition) GetLeaderEpoch() uint64 {
	if m != nil {
		return m.LeaderEpoch
	}
	return 0
}

func (m *Partition) GetEpoch() uint64 {
	if m != nil {
		return m.Epoch
	}
	return 0
}

func (m *Partition) GetPaused() bool {
	if m != nil {
		return m.Paused
	}
	return false
}

func (m *Partition) GetReadonly() bool {
	if m != nil {
		return m.Readonly
	}
	return false
}

// RaftJoinRequest is a request to join a Raft group.
type RaftJoinRequest struct {
	NodeID               string   `protobuf:"bytes,1,opt,name=nodeID,proto3" json:"nodeID,omitempty"`
	NodeAddr             string   `protobuf:"bytes,2,opt,name=nodeAddr,proto3" json:"nodeAddr,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RaftJoinRequest) Reset()         { *m = RaftJoinRequest{} }
func (m *RaftJoinRequest) String() string { return proto.CompactTextString(m) }
func (*RaftJoinRequest) ProtoMessage()    {}
func (*RaftJoinRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_41f4a519b878ee3b, []int{18}
}
func (m *RaftJoinRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RaftJoinRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RaftJoinRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RaftJoinRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RaftJoinRequest.Merge(m, src)
}
func (m *RaftJoinRequest) XXX_Size() int {
	return m.Size()
}
func (m *RaftJoinRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_RaftJoinRequest.DiscardUnknown(m)
}

var xxx_messageInfo_RaftJoinRequest proto.InternalMessageInfo

func (m *RaftJoinRequest) GetNodeID() string {
	if m != nil {
		return m.NodeID
	}
	return ""
}

func (m *RaftJoinRequest) GetNodeAddr() string {
	if m != nil {
		return m.NodeAddr
	}
	return ""
}

// RaftJoinResponse is a response to a RaftJoinRequest.
type RaftJoinResponse struct {
	Error                string   `protobuf:"bytes,1,opt,name=error,proto3" json:"error,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RaftJoinResponse) Reset()         { *m = RaftJoinResponse{} }
func (m *RaftJoinResponse) String() string { return proto.CompactTextString(m) }
func (*RaftJoinResponse) ProtoMessage()    {}
func (*RaftJoinResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_41f4a519b878ee3b, []int{19}
}
func (m *RaftJoinResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RaftJoinResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RaftJoinResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RaftJoinResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RaftJoinResponse.Merge(m, src)
}
func (m *RaftJoinResponse) XXX_Size() int {
	return m.Size()
}
func (m *RaftJoinResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_RaftJoinResponse.DiscardUnknown(m)
}

var xxx_messageInfo_RaftJoinResponse proto.InternalMessageInfo

func (m *RaftJoinResponse) GetError() string {
	if m != nil {
		return m.Error
	}
	return ""
}

type MetadataSnapshot struct {
	Streams              []*Stream `protobuf:"bytes,1,rep,name=streams,proto3" json:"streams,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *MetadataSnapshot) Reset()         { *m = MetadataSnapshot{} }
func (m *MetadataSnapshot) String() string { return proto.CompactTextString(m) }
func (*MetadataSnapshot) ProtoMessage()    {}
func (*MetadataSnapshot) Descriptor() ([]byte, []int) {
	return fileDescriptor_41f4a519b878ee3b, []int{20}
}
func (m *MetadataSnapshot) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MetadataSnapshot) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MetadataSnapshot.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MetadataSnapshot) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MetadataSnapshot.Merge(m, src)
}
func (m *MetadataSnapshot) XXX_Size() int {
	return m.Size()
}
func (m *MetadataSnapshot) XXX_DiscardUnknown() {
	xxx_messageInfo_MetadataSnapshot.DiscardUnknown(m)
}

var xxx_messageInfo_MetadataSnapshot proto.InternalMessageInfo

func (m *MetadataSnapshot) GetStreams() []*Stream {
	if m != nil {
		return m.Streams
	}
	return nil
}

type ReplicationRequest struct {
	ReplicaID            string   `protobuf:"bytes,1,opt,name=replicaID,proto3" json:"replicaID,omitempty"`
	Offset               int64    `protobuf:"varint,2,opt,name=offset,proto3" json:"offset,omitempty"`
	LeaderEpoch          uint64   `protobuf:"varint,3,opt,name=leaderEpoch,proto3" json:"leaderEpoch,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ReplicationRequest) Reset()         { *m = ReplicationRequest{} }
func (m *ReplicationRequest) String() string { return proto.CompactTextString(m) }
func (*ReplicationRequest) ProtoMessage()    {}
func (*ReplicationRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_41f4a519b878ee3b, []int{21}
}
func (m *ReplicationRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ReplicationRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ReplicationRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ReplicationRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReplicationRequest.Merge(m, src)
}
func (m *ReplicationRequest) XXX_Size() int {
	return m.Size()
}
func (m *ReplicationRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ReplicationRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ReplicationRequest proto.InternalMessageInfo

func (m *ReplicationRequest) GetReplicaID() string {
	if m != nil {
		return m.ReplicaID
	}
	return ""
}

func (m *ReplicationRequest) GetOffset() int64 {
	if m != nil {
		return m.Offset
	}
	return 0
}

func (m *ReplicationRequest) GetLeaderEpoch() uint64 {
	if m != nil {
		return m.LeaderEpoch
	}
	return 0
}

type LeaderEpochOffsetRequest struct {
	LeaderEpoch          uint64   `protobuf:"varint,1,opt,name=leaderEpoch,proto3" json:"leaderEpoch,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *LeaderEpochOffsetRequest) Reset()         { *m = LeaderEpochOffsetRequest{} }
func (m *LeaderEpochOffsetRequest) String() string { return proto.CompactTextString(m) }
func (*LeaderEpochOffsetRequest) ProtoMessage()    {}
func (*LeaderEpochOffsetRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_41f4a519b878ee3b, []int{22}
}
func (m *LeaderEpochOffsetRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LeaderEpochOffsetRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LeaderEpochOffsetRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LeaderEpochOffsetRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LeaderEpochOffsetRequest.Merge(m, src)
}
func (m *LeaderEpochOffsetRequest) XXX_Size() int {
	return m.Size()
}
func (m *LeaderEpochOffsetRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_LeaderEpochOffsetRequest.DiscardUnknown(m)
}

var xxx_messageInfo_LeaderEpochOffsetRequest proto.InternalMessageInfo

func (m *LeaderEpochOffsetRequest) GetLeaderEpoch() uint64 {
	if m != nil {
		return m.LeaderEpoch
	}
	return 0
}

type LeaderEpochOffsetResponse struct {
	EndOffset            int64    `protobuf:"varint,1,opt,name=endOffset,proto3" json:"endOffset,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *LeaderEpochOffsetResponse) Reset()         { *m = LeaderEpochOffsetResponse{} }
func (m *LeaderEpochOffsetResponse) String() string { return proto.CompactTextString(m) }
func (*LeaderEpochOffsetResponse) ProtoMessage()    {}
func (*LeaderEpochOffsetResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_41f4a519b878ee3b, []int{23}
}
func (m *LeaderEpochOffsetResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LeaderEpochOffsetResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LeaderEpochOffsetResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LeaderEpochOffsetResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LeaderEpochOffsetResponse.Merge(m, src)
}
func (m *LeaderEpochOffsetResponse) XXX_Size() int {
	return m.Size()
}
func (m *LeaderEpochOffsetResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_LeaderEpochOffsetResponse.DiscardUnknown(m)
}

var xxx_messageInfo_LeaderEpochOffsetResponse proto.InternalMessageInfo

func (m *LeaderEpochOffsetResponse) GetEndOffset() int64 {
	if m != nil {
		return m.EndOffset
	}
	return 0
}

type PropagatedRequest struct {
	Op                   Op                   `protobuf:"varint,1,opt,name=op,proto3,enum=protocol.Op" json:"op,omitempty"`
	CreateStreamOp       *CreateStreamOp      `protobuf:"bytes,2,opt,name=createStreamOp,proto3" json:"createStreamOp,omitempty"`
	ShrinkISROp          *ShrinkISROp         `protobuf:"bytes,3,opt,name=shrinkISROp,proto3" json:"shrinkISROp,omitempty"`
	ReportLeaderOp       *ReportLeaderOp      `protobuf:"bytes,4,opt,name=reportLeaderOp,proto3" json:"reportLeaderOp,omitempty"`
	ExpandISROp          *ExpandISROp         `protobuf:"bytes,5,opt,name=expandISROp,proto3" json:"expandISROp,omitempty"`
	DeleteStreamOp       *DeleteStreamOp      `protobuf:"bytes,6,opt,name=deleteStreamOp,proto3" json:"deleteStreamOp,omitempty"`
	PauseStreamOp        *PauseStreamOp       `protobuf:"bytes,7,opt,name=pauseStreamOp,proto3" json:"pauseStreamOp,omitempty"`
	ResumeStreamOp       *ResumeStreamOp      `protobuf:"bytes,8,opt,name=resumeStreamOp,proto3" json:"resumeStreamOp,omitempty"`
	SetStreamReadonlyOp  *SetStreamReadonlyOp `protobuf:"bytes,9,opt,name=setStreamReadonlyOp,proto3" json:"setStreamReadonlyOp,omitempty"`
	XXX_NoUnkeyedLiteral struct{}             `json:"-"`
	XXX_unrecognized     []byte               `json:"-"`
	XXX_sizecache        int32                `json:"-"`
}

func (m *PropagatedRequest) Reset()         { *m = PropagatedRequest{} }
func (m *PropagatedRequest) String() string { return proto.CompactTextString(m) }
func (*PropagatedRequest) ProtoMessage()    {}
func (*PropagatedRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_41f4a519b878ee3b, []int{24}
}
func (m *PropagatedRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PropagatedRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PropagatedRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PropagatedRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PropagatedRequest.Merge(m, src)
}
func (m *PropagatedRequest) XXX_Size() int {
	return m.Size()
}
func (m *PropagatedRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_PropagatedRequest.DiscardUnknown(m)
}

var xxx_messageInfo_PropagatedRequest proto.InternalMessageInfo

func (m *PropagatedRequest) GetOp() Op {
	if m != nil {
		return m.Op
	}
	return Op_CREATE_STREAM
}

func (m *PropagatedRequest) GetCreateStreamOp() *CreateStreamOp {
	if m != nil {
		return m.CreateStreamOp
	}
	return nil
}

func (m *PropagatedRequest) GetShrinkISROp() *ShrinkISROp {
	if m != nil {
		return m.ShrinkISROp
	}
	return nil
}

func (m *PropagatedRequest) GetReportLeaderOp() *ReportLeaderOp {
	if m != nil {
		return m.ReportLeaderOp
	}
	return nil
}

func (m *PropagatedRequest) GetExpandISROp() *ExpandISROp {
	if m != nil {
		return m.ExpandISROp
	}
	return nil
}

func (m *PropagatedRequest) GetDeleteStreamOp() *DeleteStreamOp {
	if m != nil {
		return m.DeleteStreamOp
	}
	return nil
}

func (m *PropagatedRequest) GetPauseStreamOp() *PauseStreamOp {
	if m != nil {
		return m.PauseStreamOp
	}
	return nil
}

func (m *PropagatedRequest) GetResumeStreamOp() *ResumeStreamOp {
	if m != nil {
		return m.ResumeStreamOp
	}
	return nil
}

func (m *PropagatedRequest) GetSetStreamReadonlyOp() *SetStreamReadonlyOp {
	if m != nil {
		return m.SetStreamReadonlyOp
	}
	return nil
}

type Error struct {
	Code                 uint32   `protobuf:"varint,1,opt,name=code,proto3" json:"code,omitempty"`
	Msg                  string   `protobuf:"bytes,2,opt,name=msg,proto3" json:"msg,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Error) Reset()         { *m = Error{} }
func (m *Error) String() string { return proto.CompactTextString(m) }
func (*Error) ProtoMessage()    {}
func (*Error) Descriptor() ([]byte, []int) {
	return fileDescriptor_41f4a519b878ee3b, []int{25}
}
func (m *Error) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Error) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Error.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Error) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Error.Merge(m, src)
}
func (m *Error) XXX_Size() int {
	return m.Size()
}
func (m *Error) XXX_DiscardUnknown() {
	xxx_messageInfo_Error.DiscardUnknown(m)
}

var xxx_messageInfo_Error proto.InternalMessageInfo

func (m *Error) GetCode() uint32 {
	if m != nil {
		return m.Code
	}
	return 0
}

func (m *Error) GetMsg() string {
	if m != nil {
		return m.Msg
	}
	return ""
}

type PropagatedResponse struct {
	Op                   Op       `protobuf:"varint,1,opt,name=op,proto3,enum=protocol.Op" json:"op,omitempty"`
	Error                *Error   `protobuf:"bytes,2,opt,name=error,proto3" json:"error,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PropagatedResponse) Reset()         { *m = PropagatedResponse{} }
func (m *PropagatedResponse) String() string { return proto.CompactTextString(m) }
func (*PropagatedResponse) ProtoMessage()    {}
func (*PropagatedResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_41f4a519b878ee3b, []int{26}
}
func (m *PropagatedResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PropagatedResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PropagatedResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PropagatedResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PropagatedResponse.Merge(m, src)
}
func (m *PropagatedResponse) XXX_Size() int {
	return m.Size()
}
func (m *PropagatedResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_PropagatedResponse.DiscardUnknown(m)
}

var xxx_messageInfo_PropagatedResponse proto.InternalMessageInfo

func (m *PropagatedResponse) GetOp() Op {
	if m != nil {
		return m.Op
	}
	return Op_CREATE_STREAM
}

func (m *PropagatedResponse) GetError() *Error {
	if m != nil {
		return m.Error
	}
	return nil
}

type ServerInfoRequest struct {
	Id                   string   `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ServerInfoRequest) Reset()         { *m = ServerInfoRequest{} }
func (m *ServerInfoRequest) String() string { return proto.CompactTextString(m) }
func (*ServerInfoRequest) ProtoMessage()    {}
func (*ServerInfoRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_41f4a519b878ee3b, []int{27}
}
func (m *ServerInfoRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ServerInfoRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ServerInfoRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ServerInfoRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ServerInfoRequest.Merge(m, src)
}
func (m *ServerInfoRequest) XXX_Size() int {
	return m.Size()
}
func (m *ServerInfoRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ServerInfoRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ServerInfoRequest proto.InternalMessageInfo

func (m *ServerInfoRequest) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

type ServerInfoResponse struct {
	Id                   string   `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	Host                 string   `protobuf:"bytes,2,opt,name=host,proto3" json:"host,omitempty"`
	Port                 int32    `protobuf:"varint,3,opt,name=port,proto3" json:"port,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ServerInfoResponse) Reset()         { *m = ServerInfoResponse{} }
func (m *ServerInfoResponse) String() string { return proto.CompactTextString(m) }
func (*ServerInfoResponse) ProtoMessage()    {}
func (*ServerInfoResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_41f4a519b878ee3b, []int{28}
}
func (m *ServerInfoResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ServerInfoResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ServerInfoResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ServerInfoResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ServerInfoResponse.Merge(m, src)
}
func (m *ServerInfoResponse) XXX_Size() int {
	return m.Size()
}
func (m *ServerInfoResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ServerInfoResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ServerInfoResponse proto.InternalMessageInfo

func (m *ServerInfoResponse) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *ServerInfoResponse) GetHost() string {
	if m != nil {
		return m.Host
	}
	return ""
}

func (m *ServerInfoResponse) GetPort() int32 {
	if m != nil {
		return m.Port
	}
	return 0
}

type PartitionStatusRequest struct {
	Stream               string   `protobuf:"bytes,1,opt,name=stream,proto3" json:"stream,omitempty"`
	Partition            int32    `protobuf:"varint,2,opt,name=partition,proto3" json:"partition,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PartitionStatusRequest) Reset()         { *m = PartitionStatusRequest{} }
func (m *PartitionStatusRequest) String() string { return proto.CompactTextString(m) }
func (*PartitionStatusRequest) ProtoMessage()    {}
func (*PartitionStatusRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_41f4a519b878ee3b, []int{29}
}
func (m *PartitionStatusRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PartitionStatusRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PartitionStatusRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PartitionStatusRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PartitionStatusRequest.Merge(m, src)
}
func (m *PartitionStatusRequest) XXX_Size() int {
	return m.Size()
}
func (m *PartitionStatusRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_PartitionStatusRequest.DiscardUnknown(m)
}

var xxx_messageInfo_PartitionStatusRequest proto.InternalMessageInfo

func (m *PartitionStatusRequest) GetStream() string {
	if m != nil {
		return m.Stream
	}
	return ""
}

func (m *PartitionStatusRequest) GetPartition() int32 {
	if m != nil {
		return m.Partition
	}
	return 0
}

type PartitionStatusResponse struct {
	Exists               bool     `protobuf:"varint,1,opt,name=exists,proto3" json:"exists,omitempty"`
	IsLeader             bool     `protobuf:"varint,2,opt,name=isLeader,proto3" json:"isLeader,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PartitionStatusResponse) Reset()         { *m = PartitionStatusResponse{} }
func (m *PartitionStatusResponse) String() string { return proto.CompactTextString(m) }
func (*PartitionStatusResponse) ProtoMessage()    {}
func (*PartitionStatusResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_41f4a519b878ee3b, []int{30}
}
func (m *PartitionStatusResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PartitionStatusResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PartitionStatusResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PartitionStatusResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PartitionStatusResponse.Merge(m, src)
}
func (m *PartitionStatusResponse) XXX_Size() int {
	return m.Size()
}
func (m *PartitionStatusResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_PartitionStatusResponse.DiscardUnknown(m)
}

var xxx_messageInfo_PartitionStatusResponse proto.InternalMessageInfo

func (m *PartitionStatusResponse) GetExists() bool {
	if m != nil {
		return m.Exists
	}
	return false
}

func (m *PartitionStatusResponse) GetIsLeader() bool {
	if m != nil {
		return m.IsLeader
	}
	return false
}

type PartitionNotification struct {
	Stream               string   `protobuf:"bytes,1,opt,name=stream,proto3" json:"stream,omitempty"`
	Partition            int32    `protobuf:"varint,2,opt,name=partition,proto3" json:"partition,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PartitionNotification) Reset()         { *m = PartitionNotification{} }
func (m *PartitionNotification) String() string { return proto.CompactTextString(m) }
func (*PartitionNotification) ProtoMessage()    {}
func (*PartitionNotification) Descriptor() ([]byte, []int) {
	return fileDescriptor_41f4a519b878ee3b, []int{31}
}
func (m *PartitionNotification) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PartitionNotification) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PartitionNotification.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PartitionNotification) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PartitionNotification.Merge(m, src)
}
func (m *PartitionNotification) XXX_Size() int {
	return m.Size()
}
func (m *PartitionNotification) XXX_DiscardUnknown() {
	xxx_messageInfo_PartitionNotification.DiscardUnknown(m)
}

var xxx_messageInfo_PartitionNotification proto.InternalMessageInfo

func (m *PartitionNotification) GetStream() string {
	if m != nil {
		return m.Stream
	}
	return ""
}

func (m *PartitionNotification) GetPartition() int32 {
	if m != nil {
		return m.Partition
	}
	return 0
}

type Cursor struct {
	Stream               string   `protobuf:"bytes,1,opt,name=stream,proto3" json:"stream,omitempty"`
	Partition            int32    `protobuf:"varint,2,opt,name=partition,proto3" json:"partition,omitempty"`
	CursorId             string   `protobuf:"bytes,3,opt,name=cursorId,proto3" json:"cursorId,omitempty"`
	Offset               int64    `protobuf:"varint,4,opt,name=offset,proto3" json:"offset,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Cursor) Reset()         { *m = Cursor{} }
func (m *Cursor) String() string { return proto.CompactTextString(m) }
func (*Cursor) ProtoMessage()    {}
func (*Cursor) Descriptor() ([]byte, []int) {
	return fileDescriptor_41f4a519b878ee3b, []int{32}
}
func (m *Cursor) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Cursor) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Cursor.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Cursor) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Cursor.Merge(m, src)
}
func (m *Cursor) XXX_Size() int {
	return m.Size()
}
func (m *Cursor) XXX_DiscardUnknown() {
	xxx_messageInfo_Cursor.DiscardUnknown(m)
}

var xxx_messageInfo_Cursor proto.InternalMessageInfo

func (m *Cursor) GetStream() string {
	if m != nil {
		return m.Stream
	}
	return ""
}

func (m *Cursor) GetPartition() int32 {
	if m != nil {
		return m.Partition
	}
	return 0
}

func (m *Cursor) GetCursorId() string {
	if m != nil {
		return m.CursorId
	}
	return ""
}

func (m *Cursor) GetOffset() int64 {
	if m != nil {
		return m.Offset
	}
	return 0
}

func init() {
	proto.RegisterEnum("protocol.Op", Op_name, Op_value)
	proto.RegisterType((*ServerState)(nil), "protocol.ServerState")
	proto.RegisterType((*RaftLog)(nil), "protocol.RaftLog")
	proto.RegisterType((*CreateStreamOp)(nil), "protocol.CreateStreamOp")
	proto.RegisterType((*ShrinkISROp)(nil), "protocol.ShrinkISROp")
	proto.RegisterType((*ExpandISROp)(nil), "protocol.ExpandISROp")
	proto.RegisterType((*DeleteStreamOp)(nil), "protocol.DeleteStreamOp")
	proto.RegisterType((*PauseStreamOp)(nil), "protocol.PauseStreamOp")
	proto.RegisterType((*ResumeStreamOp)(nil), "protocol.ResumeStreamOp")
	proto.RegisterType((*ReportLeaderOp)(nil), "protocol.ReportLeaderOp")
	proto.RegisterType((*ChangeLeaderOp)(nil), "protocol.ChangeLeaderOp")
	proto.RegisterType((*PublishActivityOp)(nil), "protocol.PublishActivityOp")
	proto.RegisterType((*SetStreamReadonlyOp)(nil), "protocol.SetStreamReadonlyOp")
	proto.RegisterType((*NullableInt64)(nil), "protocol.NullableInt64")
	proto.RegisterType((*NullableInt32)(nil), "protocol.NullableInt32")
	proto.RegisterType((*NullableBool)(nil), "protocol.NullableBool")
	proto.RegisterType((*StreamConfig)(nil), "protocol.StreamConfig")
	proto.RegisterType((*Stream)(nil), "protocol.Stream")
	proto.RegisterType((*Partition)(nil), "protocol.Partition")
	proto.RegisterType((*RaftJoinRequest)(nil), "protocol.RaftJoinRequest")
	proto.RegisterType((*RaftJoinResponse)(nil), "protocol.RaftJoinResponse")
	proto.RegisterType((*MetadataSnapshot)(nil), "protocol.MetadataSnapshot")
	proto.RegisterType((*ReplicationRequest)(nil), "protocol.ReplicationRequest")
	proto.RegisterType((*LeaderEpochOffsetRequest)(nil), "protocol.LeaderEpochOffsetRequest")
	proto.RegisterType((*LeaderEpochOffsetResponse)(nil), "protocol.LeaderEpochOffsetResponse")
	proto.RegisterType((*PropagatedRequest)(nil), "protocol.PropagatedRequest")
	proto.RegisterType((*Error)(nil), "protocol.Error")
	proto.RegisterType((*PropagatedResponse)(nil), "protocol.PropagatedResponse")
	proto.RegisterType((*ServerInfoRequest)(nil), "protocol.ServerInfoRequest")
	proto.RegisterType((*ServerInfoResponse)(nil), "protocol.ServerInfoResponse")
	proto.RegisterType((*PartitionStatusRequest)(nil), "protocol.PartitionStatusRequest")
	proto.RegisterType((*PartitionStatusResponse)(nil), "protocol.PartitionStatusResponse")
	proto.RegisterType((*PartitionNotification)(nil), "protocol.PartitionNotification")
	proto.RegisterType((*Cursor)(nil), "protocol.Cursor")
}

func init() { proto.RegisterFile("internal.proto", fileDescriptor_41f4a519b878ee3b) }

var fileDescriptor_41f4a519b878ee3b = []byte{
	// 1590 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xe4, 0x58, 0x5f, 0x6f, 0x1b, 0x37,
	0x12, 0x8f, 0xfe, 0x5a, 0x1a, 0xd9, 0x8a, 0x4c, 0x27, 0x8e, 0x2e, 0xe7, 0x18, 0xc6, 0xde, 0x05,
	0xd0, 0x05, 0x77, 0x3e, 0x9c, 0x73, 0xb8, 0x43, 0x8b, 0x36, 0xa8, 0x6c, 0x6f, 0x63, 0x35, 0xb2,
	0x65, 0x50, 0x4a, 0xd1, 0x14, 0x45, 0x8d, 0xf5, 0x2e, 0x25, 0x6f, 0xbb, 0x5a, 0x6e, 0x49, 0xca,
	0x70, 0xbe, 0x49, 0xd1, 0xb7, 0x3e, 0xf5, 0x43, 0xf4, 0xb1, 0x7d, 0x68, 0xdf, 0xfa, 0x11, 0xda,
	0xf4, 0x6b, 0xf4, 0xa1, 0x20, 0x97, 0xfb, 0x57, 0x96, 0x8b, 0x2a, 0x2f, 0x05, 0xfa, 0x24, 0xce,
	0xf0, 0x37, 0x3f, 0x0e, 0xb9, 0xc3, 0x99, 0xa1, 0xa0, 0xe9, 0xfa, 0x82, 0x30, 0xdf, 0xf2, 0x76,
	0x03, 0x46, 0x05, 0x45, 0x35, 0xf5, 0x63, 0x53, 0xcf, 0xf8, 0x07, 0x34, 0x86, 0x84, 0x5d, 0x12,
	0x36, 0x14, 0x96, 0x20, 0xe8, 0x3e, 0xd4, 0xb8, 0x12, 0x7b, 0x87, 0xed, 0xc2, 0x4e, 0xa1, 0x53,
	0xc7, 0xb1, 0x6c, 0xfc, 0x52, 0x86, 0x15, 0x6c, 0x8d, 0x45, 0x9f, 0x4e, 0xd0, 0x16, 0x14, 0x69,
	0xa0, 0x10, 0xcd, 0xbd, 0xd5, 0xdd, 0x88, 0x6d, 0x77, 0x10, 0xe0, 0x22, 0x0d, 0xd0, 0x3b, 0xd0,
	0xb4, 0x19, 0xb1, 0x04, 0x19, 0x0a, 0x46, 0xac, 0xe9, 0x20, 0x68, 0x17, 0x77, 0x0a, 0x9d, 0xc6,
	0x5e, 0x3b, 0x41, 0x1e, 0x64, 0xe6, 0x71, 0x0e, 0x8f, 0xfe, 0x0f, 0x0d, 0x7e, 0xc1, 0x5c, 0xff,
	0xd3, 0xde, 0x10, 0x0f, 0x82, 0x76, 0x49, 0x99, 0xdf, 0x4d, 0xcc, 0x87, 0xc9, 0x24, 0x4e, 0x23,
	0xd5, 0xd2, 0x17, 0x96, 0x3f, 0x21, 0x7d, 0x62, 0x39, 0x84, 0x0d, 0x82, 0x76, 0x79, 0x6e, 0xe9,
	0xcc, 0x3c, 0xce, 0xe1, 0xe5, 0xd2, 0xe4, 0x2a, 0xb0, 0x7c, 0x27, 0x5c, 0xba, 0x92, 0x5f, 0xda,
	0x4c, 0x26, 0x71, 0x1a, 0x29, 0x97, 0x76, 0x88, 0x47, 0x52, 0xbb, 0xae, 0xe6, 0x97, 0x3e, 0xcc,
	0xcc, 0xe3, 0x1c, 0x1e, 0xbd, 0x0d, 0x6b, 0x81, 0x35, 0xe3, 0x09, 0xc1, 0x8a, 0x22, 0xb8, 0x97,
	0x10, 0x9c, 0xa6, 0xa7, 0x71, 0x16, 0x2d, 0x1d, 0x60, 0x84, 0xcf, 0xa6, 0x89, 0x7d, 0x2d, 0xef,
	0x00, 0xce, 0xcc, 0xe3, 0x1c, 0x1e, 0xf5, 0x60, 0x3d, 0x98, 0x9d, 0x7b, 0x2e, 0xbf, 0xe8, 0xda,
	0xc2, 0xbd, 0x74, 0xc5, 0xcb, 0x41, 0xd0, 0xae, 0x2b, 0x92, 0xbf, 0xa6, 0x9c, 0xc8, 0x43, 0xf0,
	0xbc, 0x15, 0x1a, 0xc0, 0x06, 0x27, 0x22, 0x64, 0xc6, 0xc4, 0x72, 0xa8, 0xef, 0x49, 0x32, 0x50,
	0x64, 0x0f, 0x52, 0x5f, 0x72, 0x1e, 0x84, 0xaf, 0xb3, 0x34, 0xde, 0x84, 0x66, 0x36, 0x68, 0x50,
	0x07, 0xaa, 0x5c, 0x8d, 0x55, 0x20, 0x36, 0xf6, 0x5a, 0x29, 0xd6, 0xd0, 0x5a, 0xcf, 0x1b, 0x5f,
	0x15, 0xa0, 0x91, 0x0a, 0x19, 0xb4, 0x99, 0xb1, 0xac, 0x47, 0x38, 0xb4, 0x05, 0xf5, 0xc0, 0x62,
	0xc2, 0x15, 0x2e, 0xf5, 0x55, 0xcc, 0x56, 0x70, 0xa2, 0x40, 0x1d, 0xb8, 0xcd, 0x48, 0xe0, 0xb9,
	0xb6, 0x35, 0xa2, 0x98, 0x4c, 0xe9, 0x25, 0x51, 0x81, 0x59, 0xc7, 0x79, 0xb5, 0xe4, 0xf7, 0x54,
	0x3c, 0xa9, 0xe8, 0xab, 0x63, 0x2d, 0xa1, 0x1d, 0x68, 0x84, 0x23, 0x33, 0xa0, 0xf6, 0x85, 0x8a,
	0xad, 0x32, 0x4e, 0xab, 0x8c, 0x2f, 0x0b, 0xd0, 0x48, 0x45, 0xd8, 0x92, 0x9e, 0x1a, 0xb0, 0x1a,
	0xbb, 0xd4, 0x75, 0x1c, 0xed, 0x66, 0x46, 0xf7, 0x1a, 0x3e, 0x76, 0xa0, 0x99, 0x0d, 0xe4, 0x45,
	0x5e, 0x1a, 0x04, 0xd6, 0x32, 0x11, 0xbb, 0x70, 0x3b, 0xdb, 0x00, 0xb1, 0xf7, 0xbc, 0x5d, 0xdc,
	0x29, 0x75, 0x2a, 0x38, 0xa5, 0x91, 0xdb, 0x0d, 0x43, 0xb5, 0xeb, 0x79, 0x6a, 0x37, 0x35, 0x9c,
	0x28, 0x8c, 0x23, 0x68, 0x66, 0x03, 0x7b, 0xd9, 0x75, 0x8c, 0x2f, 0x0a, 0x92, 0x2a, 0xa0, 0x4c,
	0xc4, 0xf9, 0x60, 0xb9, 0x2f, 0xd0, 0x86, 0x15, 0x7d, 0xda, 0xfa, 0xf0, 0x23, 0xf1, 0x35, 0xce,
	0xfd, 0x63, 0x68, 0x66, 0x73, 0xd7, 0x92, 0xbe, 0x25, 0x1e, 0x94, 0xd2, 0x1e, 0x18, 0xff, 0x81,
	0xf5, 0xb9, 0xab, 0xad, 0x4e, 0xde, 0x1a, 0x8b, 0x9e, 0xef, 0x90, 0x2b, 0xb5, 0x4a, 0x19, 0x27,
	0x0a, 0xc3, 0x85, 0x8d, 0x6b, 0x2e, 0xf0, 0xd2, 0x9f, 0xf9, 0x3e, 0xd4, 0x98, 0x66, 0xd1, 0x5f,
	0x39, 0x96, 0x8d, 0x87, 0xb0, 0x76, 0x32, 0xf3, 0x3c, 0xeb, 0xdc, 0x23, 0x3d, 0x5f, 0xfc, 0xef,
	0xbf, 0xe8, 0x0e, 0x54, 0x2e, 0x2d, 0x6f, 0x46, 0xd4, 0x1a, 0x25, 0x1c, 0x0a, 0x39, 0xd8, 0xe3,
	0xbd, 0x2c, 0xac, 0x12, 0xc1, 0xfe, 0x0e, 0xab, 0x11, 0x6c, 0x9f, 0x52, 0x2f, 0x8b, 0xaa, 0x45,
	0xa8, 0x9f, 0xaa, 0xb0, 0x1a, 0x6e, 0xee, 0x80, 0xfa, 0x63, 0x77, 0x82, 0x4c, 0x58, 0x67, 0x44,
	0x10, 0x5f, 0xba, 0x7b, 0x6c, 0x5d, 0xed, 0xbf, 0x14, 0x84, 0xeb, 0xec, 0x93, 0xca, 0xd2, 0x19,
	0x3f, 0xf1, 0xbc, 0x05, 0x7a, 0x06, 0x77, 0xd2, 0xca, 0x63, 0xc2, 0xb9, 0x35, 0x21, 0x5c, 0x97,
	0xc9, 0x85, 0x4c, 0xd7, 0x1a, 0xa1, 0xae, 0x4c, 0x4b, 0x89, 0xbe, 0x3b, 0x21, 0xba, 0x5e, 0x2e,
	0xe4, 0xc9, 0xe3, 0x25, 0x85, 0xed, 0x11, 0xcb, 0x27, 0xac, 0x27, 0x1b, 0x85, 0x4b, 0xcb, 0xd3,
	0x65, 0x73, 0x31, 0x45, 0x0e, 0x2f, 0x29, 0x38, 0x99, 0x4c, 0x89, 0x2f, 0xe2, 0x73, 0xa9, 0xfc,
	0x06, 0x45, 0x0e, 0x2f, 0xcb, 0x5f, 0xa2, 0x92, 0xdb, 0xa8, 0xde, 0x4c, 0x90, 0x45, 0xcb, 0x43,
	0xb5, 0xe9, 0x34, 0xb0, 0x6c, 0xa9, 0x78, 0x4a, 0x19, 0x9d, 0x09, 0xd7, 0x27, 0x7c, 0xbe, 0x88,
	0x66, 0xe2, 0x03, 0x5f, 0x6b, 0x84, 0x9e, 0x40, 0x53, 0xeb, 0x4d, 0x5f, 0x62, 0x1d, 0x5d, 0x4b,
	0x37, 0xe7, 0x69, 0x64, 0xfc, 0xe0, 0x1c, 0x5a, 0xee, 0xc5, 0x9a, 0x09, 0xaa, 0xb2, 0xdf, 0xc8,
	0x9d, 0x12, 0x5d, 0x45, 0x17, 0xef, 0x25, 0x83, 0x46, 0x1f, 0xc1, 0x83, 0x58, 0x71, 0xe8, 0x72,
	0x85, 0x1b, 0x0f, 0x67, 0xe7, 0xdc, 0x66, 0xee, 0x39, 0x61, 0x5c, 0xd7, 0xd1, 0x45, 0xde, 0xdc,
	0x6c, 0x8c, 0xfe, 0x0d, 0xd5, 0xa9, 0xeb, 0xf7, 0x38, 0x6b, 0x37, 0x6e, 0x3e, 0x1b, 0x0d, 0x43,
	0x1f, 0xc2, 0x16, 0x0d, 0x84, 0x3b, 0x75, 0xb9, 0x70, 0xed, 0x03, 0xea, 0xdb, 0x33, 0xc6, 0x88,
	0x6f, 0xbf, 0x3c, 0xa0, 0xbe, 0x60, 0xd4, 0x6b, 0xaf, 0xde, 0xe8, 0xcd, 0x8d, 0xb6, 0xc6, 0xf7,
	0x05, 0xa8, 0x86, 0x77, 0x0c, 0x21, 0x28, 0xfb, 0xd6, 0x94, 0xe8, 0xa4, 0xa1, 0xc6, 0x32, 0x91,
	0xf2, 0xd9, 0xf9, 0x27, 0xc4, 0x16, 0xea, 0x76, 0xd4, 0x71, 0x24, 0xa2, 0xc7, 0x99, 0x64, 0x52,
	0xda, 0x29, 0x75, 0x1a, 0x7b, 0x1b, 0xe9, 0x56, 0x49, 0xcf, 0x65, 0x32, 0xcc, 0x2e, 0x54, 0x6d,
	0x75, 0x95, 0x75, 0x80, 0x6f, 0xe6, 0x7b, 0x86, 0xf0, 0xa2, 0x63, 0x8d, 0x42, 0xff, 0x84, 0x75,
	0xd5, 0x9a, 0xba, 0xd4, 0x97, 0x1f, 0x86, 0x0b, 0x6b, 0x1a, 0xf6, 0x84, 0x25, 0x3c, 0x3f, 0x61,
	0x7c, 0x53, 0x84, 0xfa, 0x69, 0xba, 0x06, 0x44, 0xae, 0x17, 0xb2, 0xae, 0x27, 0xf9, 0xb1, 0x98,
	0xc9, 0x8f, 0x4d, 0x28, 0xba, 0x61, 0xb5, 0xae, 0xe0, 0xa2, 0xeb, 0xc8, 0xac, 0x34, 0x61, 0x74,
	0x16, 0xe8, 0x52, 0x11, 0x0a, 0xd2, 0x27, 0x5d, 0x4c, 0xe4, 0x32, 0xef, 0x5a, 0xb6, 0xa0, 0x4c,
	0xf9, 0x54, 0xc1, 0xf3, 0x13, 0x61, 0x4e, 0x55, 0x4a, 0xde, 0xae, 0xee, 0x94, 0x64, 0x4b, 0x1f,
	0xc9, 0xa9, 0x4a, 0xb0, 0x92, 0xa9, 0x45, 0x2d, 0x28, 0xb9, 0x9c, 0xb5, 0x6b, 0x0a, 0x2e, 0x87,
	0xf9, 0xea, 0x54, 0x9f, 0xab, 0x4e, 0xd2, 0x57, 0xa2, 0xe6, 0x40, 0xcd, 0x85, 0x82, 0x5c, 0x41,
	0x35, 0xa9, 0x8e, 0x0a, 0xb5, 0x1a, 0xd6, 0x52, 0x26, 0xd3, 0xaf, 0xe6, 0x32, 0xbd, 0x09, 0xb7,
	0xe5, 0x3b, 0xe3, 0x3d, 0xea, 0xfa, 0x98, 0x7c, 0x36, 0x23, 0x5c, 0x1d, 0x98, 0x4f, 0x1d, 0x12,
	0xbf, 0x4a, 0xb4, 0x24, 0x69, 0xe4, 0xa8, 0xeb, 0x38, 0x4c, 0x1f, 0x65, 0x2c, 0x1b, 0x1d, 0x68,
	0x25, 0x34, 0x3c, 0xa0, 0x3e, 0x27, 0xca, 0x49, 0xc6, 0x28, 0xd3, 0x34, 0xa1, 0x60, 0x3c, 0x81,
	0xd6, 0x31, 0x11, 0x96, 0x63, 0x09, 0x6b, 0xe8, 0x5b, 0x01, 0xbf, 0xa0, 0x02, 0x3d, 0x82, 0x95,
	0xf0, 0xa3, 0xc8, 0xfc, 0x5e, 0xba, 0xb6, 0xbb, 0x8c, 0x00, 0x86, 0x07, 0x08, 0x27, 0xe7, 0x1e,
	0xf9, 0xac, 0x7a, 0x16, 0xa5, 0x8d, 0xdd, 0x4e, 0x14, 0x72, 0x47, 0x74, 0x3c, 0xe6, 0x24, 0x0c,
	0xeb, 0x12, 0xd6, 0x52, 0xfe, 0xa0, 0x4b, 0xf3, 0x6d, 0xc0, 0x5b, 0xd0, 0xee, 0x27, 0xe2, 0x40,
	0x99, 0x45, 0x6b, 0xe6, 0xac, 0x0b, 0xf3, 0xd6, 0x6f, 0xc0, 0x5f, 0xae, 0xb1, 0xd6, 0xc7, 0xb3,
	0x05, 0x75, 0xe2, 0x3b, 0xa1, 0x52, 0x97, 0xd5, 0x44, 0x61, 0x7c, 0x5d, 0x86, 0xf5, 0x53, 0x46,
	0x03, 0x6b, 0x62, 0x09, 0xe2, 0x24, 0xdb, 0xfc, 0xe3, 0x3e, 0x05, 0x59, 0xa6, 0x95, 0x9b, 0x7f,
	0x0a, 0x66, 0x5b, 0x3d, 0x9c, 0xc3, 0xff, 0xa9, 0x9f, 0x82, 0x0b, 0xde, 0x6f, 0xf5, 0xa5, 0xdf,
	0x6f, 0xff, 0x82, 0x8a, 0x29, 0x6f, 0x9b, 0xcc, 0xf2, 0x36, 0x75, 0xc2, 0x2c, 0xbf, 0x86, 0xd5,
	0x58, 0x26, 0x9c, 0x29, 0x9f, 0xe8, 0x2b, 0x2c, 0x87, 0xc6, 0x0b, 0x40, 0xe9, 0x58, 0x8b, 0x03,
	0xf4, 0xa6, 0x60, 0x7b, 0x18, 0xdd, 0xee, 0x30, 0xc6, 0x6e, 0xa7, 0xbe, 0x94, 0x54, 0x47, 0xd7,
	0xfd, 0x6f, 0xb0, 0x1e, 0xfe, 0xe7, 0xd1, 0xf3, 0xc7, 0x34, 0x0a, 0xe3, 0x30, 0xf5, 0x86, 0xd7,
	0xb4, 0xe8, 0x3a, 0x46, 0x1f, 0x50, 0x1a, 0xa4, 0xd7, 0xcf, 0xa1, 0xe4, 0x5e, 0x2e, 0x28, 0x8f,
	0x4a, 0x93, 0x1a, 0x4b, 0x9d, 0x8c, 0x22, 0x9d, 0xc6, 0xd5, 0xd8, 0x38, 0x81, 0xcd, 0xb8, 0x2e,
	0x0c, 0x85, 0x25, 0x66, 0x3c, 0x95, 0xd9, 0x7e, 0x7f, 0x0b, 0x6f, 0x1c, 0xc3, 0xbd, 0x39, 0x3e,
	0xed, 0xe2, 0x26, 0x54, 0xc9, 0x95, 0xcb, 0x05, 0xd7, 0xad, 0xac, 0x96, 0x64, 0xaa, 0x74, 0x79,
	0x18, 0xda, 0x8a, 0xaf, 0x86, 0x63, 0xd9, 0x38, 0x86, 0xbb, 0x31, 0xdd, 0x09, 0x15, 0xee, 0x58,
	0xa7, 0xb2, 0x25, 0xbd, 0x63, 0x50, 0x3d, 0x98, 0x31, 0x4e, 0xd9, 0x92, 0x0f, 0x94, 0xfb, 0x50,
	0xb3, 0x95, 0x7d, 0x2f, 0x7a, 0xba, 0xc6, 0x72, 0x2a, 0x6f, 0x96, 0xd3, 0x79, 0xf3, 0xd1, 0xb7,
	0x05, 0x28, 0x0e, 0x02, 0xb4, 0x0e, 0x6b, 0x07, 0xd8, 0xec, 0x8e, 0xcc, 0xb3, 0xe1, 0x08, 0x9b,
	0xdd, 0xe3, 0xd6, 0x2d, 0xd4, 0x04, 0x18, 0x1e, 0xe1, 0xde, 0xc9, 0xb3, 0xb3, 0xde, 0x10, 0xb7,
	0x0a, 0x12, 0x82, 0xcd, 0xd3, 0x01, 0x1e, 0x9d, 0xf5, 0xcd, 0xee, 0xa1, 0x89, 0x5b, 0x45, 0x65,
	0x75, 0xd4, 0x3d, 0x79, 0x6a, 0x46, 0xaa, 0x92, 0xb4, 0x32, 0x3f, 0x38, 0xed, 0x9e, 0x1c, 0x2a,
	0xab, 0xb2, 0x84, 0x1c, 0x9a, 0x7d, 0x33, 0x21, 0xae, 0xa0, 0x16, 0xac, 0x9e, 0x76, 0x9f, 0x0f,
	0x63, 0x4d, 0x35, 0xa4, 0x1e, 0x3e, 0x3f, 0x8e, 0x55, 0x2b, 0xe8, 0x0e, 0xb4, 0x4e, 0x9f, 0xef,
	0xf7, 0x7b, 0xc3, 0xa3, 0xb3, 0xee, 0xc1, 0xa8, 0xf7, 0x7e, 0x6f, 0xf4, 0xa2, 0x55, 0x43, 0xf7,
	0x60, 0x63, 0x68, 0x8e, 0x34, 0xea, 0x0c, 0x9b, 0xdd, 0xc3, 0xc1, 0x49, 0xff, 0x45, 0xab, 0xbe,
	0xdf, 0xfa, 0xee, 0xd5, 0x76, 0xe1, 0x87, 0x57, 0xdb, 0x85, 0x1f, 0x5f, 0x6d, 0x17, 0x3e, 0xff,
	0x79, 0xfb, 0xd6, 0x79, 0x55, 0x05, 0xf1, 0xe3, 0x5f, 0x03, 0x00, 0x00, 0xff, 0xff, 0x3b, 0x21,
	0x94, 0x0a, 0xc4, 0x13, 0x00, 0x00,
}

func (m *ServerState) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ServerState) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ServerID) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintInternal(dAtA, i, uint64(len(m.ServerID)))
		i += copy(dAtA[i:], m.ServerID)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *RaftLog) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RaftLog) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Op != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintInternal(dAtA, i, uint64(m.Op))
	}
	if m.CreateStreamOp != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintInternal(dAtA, i, uint64(m.CreateStreamOp.Size()))
		n1, err1 := m.CreateStreamOp.MarshalTo(dAtA[i:])
		if err1 != nil {
			return 0, err1
		}
		i += n1
	}
	if m.ShrinkISROp != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintInternal(dAtA, i, uint64(m.ShrinkISROp.Size()))
		n2, err2 := m.ShrinkISROp.MarshalTo(dAtA[i:])
		if err2 != nil {
			return 0, err2
		}
		i += n2
	}
	if m.ChangeLeaderOp != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintInternal(dAtA, i, uint64(m.ChangeLeaderOp.Size()))
		n3, err3 := m.ChangeLeaderOp.MarshalTo(dAtA[i:])
		if err3 != nil {
			return 0, err3
		}
		i += n3
	}
	if m.ExpandISROp != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintInternal(dAtA, i, uint64(m.ExpandISROp.Size()))
		n4, err4 := m.ExpandISROp.MarshalTo(dAtA[i:])
		if err4 != nil {
			return 0, err4
		}
		i += n4
	}
	if m.DeleteStreamOp != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintInternal(dAtA, i, uint64(m.DeleteStreamOp.Size()))
		n5, err5 := m.DeleteStreamOp.MarshalTo(dAtA[i:])
		if err5 != nil {
			return 0, err5
		}
		i += n5
	}
	if m.PauseStreamOp != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintInternal(dAtA, i, uint64(m.PauseStreamOp.Size()))
		n6, err6 := m.PauseStreamOp.MarshalTo(dAtA[i:])
		if err6 != nil {
			return 0, err6
		}
		i += n6
	}
	if m.ResumeStreamOp != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintInternal(dAtA, i, uint64(m.ResumeStreamOp.Size()))
		n7, err7 := m.ResumeStreamOp.MarshalTo(dAtA[i:])
		if err7 != nil {
			return 0, err7
		}
		i += n7
	}
	if m.PublishActivityOp != nil {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintInternal(dAtA, i, uint64(m.PublishActivityOp.Size()))
		n8, err8 := m.PublishActivityOp.MarshalTo(dAtA[i:])
		if err8 != nil {
			return 0, err8
		}
		i += n8
	}
	if m.SetStreamReadonlyOp != nil {
		dAtA[i] = 0x52
		i++
		i = encodeVarintInternal(dAtA, i, uint64(m.SetStreamReadonlyOp.Size()))
		n9, err9 := m.SetStreamReadonlyOp.MarshalTo(dAtA[i:])
		if err9 != nil {
			return 0, err9
		}
		i += n9
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *CreateStreamOp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateStreamOp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Stream != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintInternal(dAtA, i, uint64(m.Stream.Size()))
		n10, err10 := m.Stream.MarshalTo(dAtA[i:])
		if err10 != nil {
			return 0, err10
		}
		i += n10
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ShrinkISROp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ShrinkISROp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Stream) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintInternal(dAtA, i, uint64(len(m.Stream)))
		i += copy(dAtA[i:], m.Stream)
	}
	if m.Partition != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintInternal(dAtA, i, uint64(m.Partition))
	}
	if len(m.ReplicaToRemove) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintInternal(dAtA, i, uint64(len(m.ReplicaToRemove)))
		i += copy(dAtA[i:], m.ReplicaToRemove)
	}
	if len(m.Leader) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintInternal(dAtA, i, uint64(len(m.Leader)))
		i += copy(dAtA[i:], m.Leader)
	}
	if m.LeaderEpoch != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintInternal(dAtA, i, uint64(m.LeaderEpoch))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ExpandISROp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ExpandISROp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Stream) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintInternal(dAtA, i, uint64(len(m.Stream)))
		i += copy(dAtA[i:], m.Stream)
	}
	if m.Partition != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintInternal(dAtA, i, uint64(m.Partition))
	}
	if len(m.ReplicaToAdd) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintInternal(dAtA, i, uint64(len(m.ReplicaToAdd)))
		i += copy(dAtA[i:], m.ReplicaToAdd)
	}
	if len(m.Leader) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintInternal(dAtA, i, uint64(len(m.Leader)))
		i += copy(dAtA[i:], m.Leader)
	}
	if m.LeaderEpoch != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintInternal(dAtA, i, uint64(m.LeaderEpoch))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *DeleteStreamOp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeleteStreamOp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Stream) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintInternal(dAtA, i, uint64(len(m.Stream)))
		i += copy(dAtA[i:], m.Stream)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *PauseStreamOp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PauseStreamOp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Stream) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintInternal(dAtA, i, uint64(len(m.Stream)))
		i += copy(dAtA[i:], m.Stream)
	}
	if len(m.Partitions) > 0 {
		dAtA12 := make([]byte, len(m.Partitions)*10)
		var j11 int
		for _, num1 := range m.Partitions {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA12[j11] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j11++
			}
			dAtA12[j11] = uint8(num)
			j11++
		}
		dAtA[i] = 0x12
		i++
		i = encodeVarintInternal(dAtA, i, uint64(j11))
		i += copy(dAtA[i:], dAtA12[:j11])
	}
	if m.ResumeAll {
		dAtA[i] = 0x18
		i++
		if m.ResumeAll {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ResumeStreamOp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ResumeStreamOp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Stream) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintInternal(dAtA, i, uint64(len(m.Stream)))
		i += copy(dAtA[i:], m.Stream)
	}
	if len(m.Partitions) > 0 {
		dAtA14 := make([]byte, len(m.Partitions)*10)
		var j13 int
		for _, num1 := range m.Partitions {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA14[j13] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j13++
			}
			dAtA14[j13] = uint8(num)
			j13++
		}
		dAtA[i] = 0x12
		i++
		i = encodeVarintInternal(dAtA, i, uint64(j13))
		i += copy(dAtA[i:], dAtA14[:j13])
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ReportLeaderOp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReportLeaderOp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Stream) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintInternal(dAtA, i, uint64(len(m.Stream)))
		i += copy(dAtA[i:], m.Stream)
	}
	if m.Partition != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintInternal(dAtA, i, uint64(m.Partition))
	}
	if len(m.Replica) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintInternal(dAtA, i, uint64(len(m.Replica)))
		i += copy(dAtA[i:], m.Replica)
	}
	if len(m.Leader) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintInternal(dAtA, i, uint64(len(m.Leader)))
		i += copy(dAtA[i:], m.Leader)
	}
	if m.LeaderEpoch != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintInternal(dAtA, i, uint64(m.LeaderEpoch))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ChangeLeaderOp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ChangeLeaderOp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Stream) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintInternal(dAtA, i, uint64(len(m.Stream)))
		i += copy(dAtA[i:], m.Stream)
	}
	if m.Partition != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintInternal(dAtA, i, uint64(m.Partition))
	}
	if len(m.Leader) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintInternal(dAtA, i, uint64(len(m.Leader)))
		i += copy(dAtA[i:], m.Leader)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *PublishActivityOp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PublishActivityOp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.RaftIndex != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintInternal(dAtA, i, uint64(m.RaftIndex))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *SetStreamReadonlyOp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SetStreamReadonlyOp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Stream) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintInternal(dAtA, i, uint64(len(m.Stream)))
		i += copy(dAtA[i:], m.Stream)
	}
	if len(m.Partitions) > 0 {
		dAtA16 := make([]byte, len(m.Partitions)*10)
		var j15 int
		for _, num1 := range m.Partitions {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA16[j15] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j15++
			}
			dAtA16[j15] = uint8(num)
			j15++
		}
		dAtA[i] = 0x12
		i++
		i = encodeVarintInternal(dAtA, i, uint64(j15))
		i += copy(dAtA[i:], dAtA16[:j15])
	}
	if m.Readonly {
		dAtA[i] = 0x18
		i++
		if m.Readonly {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *NullableInt64) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NullableInt64) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Value != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintInternal(dAtA, i, uint64(m.Value))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *NullableInt32) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NullableInt32) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Value != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintInternal(dAtA, i, uint64(m.Value))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *NullableBool) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NullableBool) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Value {
		dAtA[i] = 0x8
		i++
		if m.Value {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *StreamConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StreamConfig) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.RetentionMaxBytes != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintInternal(dAtA, i, uint64(m.RetentionMaxBytes.Size()))
		n17, err17 := m.RetentionMaxBytes.MarshalTo(dAtA[i:])
		if err17 != nil {
			return 0, err17
		}
		i += n17
	}
	if m.RetentionMaxMessages != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintInternal(dAtA, i, uint64(m.RetentionMaxMessages.Size()))
		n18, err18 := m.RetentionMaxMessages.MarshalTo(dAtA[i:])
		if err18 != nil {
			return 0, err18
		}
		i += n18
	}
	if m.RetentionMaxAge != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintInternal(dAtA, i, uint64(m.RetentionMaxAge.Size()))
		n19, err19 := m.RetentionMaxAge.MarshalTo(dAtA[i:])
		if err19 != nil {
			return 0, err19
		}
		i += n19
	}
	if m.CleanerInterval != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintInternal(dAtA, i, uint64(m.CleanerInterval.Size()))
		n20, err20 := m.CleanerInterval.MarshalTo(dAtA[i:])
		if err20 != nil {
			return 0, err20
		}
		i += n20
	}
	if m.SegmentMaxBytes != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintInternal(dAtA, i, uint64(m.SegmentMaxBytes.Size()))
		n21, err21 := m.SegmentMaxBytes.MarshalTo(dAtA[i:])
		if err21 != nil {
			return 0, err21
		}
		i += n21
	}
	if m.SegmentMaxAge != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintInternal(dAtA, i, uint64(m.SegmentMaxAge.Size()))
		n22, err22 := m.SegmentMaxAge.MarshalTo(dAtA[i:])
		if err22 != nil {
			return 0, err22
		}
		i += n22
	}
	if m.CompactMaxGoroutines != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintInternal(dAtA, i, uint64(m.CompactMaxGoroutines.Size()))
		n23, err23 := m.CompactMaxGoroutines.MarshalTo(dAtA[i:])
		if err23 != nil {
			return 0, err23
		}
		i += n23
	}
	if m.CompactEnabled != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintInternal(dAtA, i, uint64(m.CompactEnabled.Size()))
		n24, err24 := m.CompactEnabled.MarshalTo(dAtA[i:])
		if err24 != nil {
			return 0, err24
		}
		i += n24
	}
	if m.AutoPauseTime != nil {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintInternal(dAtA, i, uint64(m.AutoPauseTime.Size()))
		n25, err25 := m.AutoPauseTime.MarshalTo(dAtA[i:])
		if err25 != nil {
			return 0, err25
		}
		i += n25
	}
	if m.AutoPauseDisableIfSubscribers != nil {
		dAtA[i] = 0x52
		i++
		i = encodeVarintInternal(dAtA, i, uint64(m.AutoPauseDisableIfSubscribers.Size()))
		n26, err26 := m.AutoPauseDisableIfSubscribers.MarshalTo(dAtA[i:])
		if err26 != nil {
			return 0, err26
		}
		i += n26
	}
	if m.MinIsr != nil {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintInternal(dAtA, i, uint64(m.MinIsr.Size()))
		n27, err27 := m.MinIsr.MarshalTo(dAtA[i:])
		if err27 != nil {
			return 0, err27
		}
		i += n27
	}
	if m.OptimisticConcurrencyControl != nil {
		dAtA[i] = 0x62
		i++
		i = encodeVarintInternal(dAtA, i, uint64(m.OptimisticConcurrencyControl.Size()))
		n28, err28 := m.OptimisticConcurrencyControl.MarshalTo(dAtA[i:])
		if err28 != nil {
			return 0, err28
		}
		i += n28
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Stream) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Stream) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintInternal(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Subject) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintInternal(dAtA, i, uint64(len(m.Subject)))
		i += copy(dAtA[i:], m.Subject)
	}
	if len(m.Partitions) > 0 {
		for _, msg := range m.Partitions {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintInternal(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Config != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintInternal(dAtA, i, uint64(m.Config.Size()))
		n29, err29 := m.Config.MarshalTo(dAtA[i:])
		if err29 != nil {
			return 0, err29
		}
		i += n29
	}
	if m.CreationTimestamp != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintInternal(dAtA, i, uint64(m.CreationTimestamp))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Partition) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Partition) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Subject) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintInternal(dAtA, i, uint64(len(m.Subject)))
		i += copy(dAtA[i:], m.Subject)
	}
	if len(m.Stream) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintInternal(dAtA, i, uint64(len(m.Stream)))
		i += copy(dAtA[i:], m.Stream)
	}
	if m.Id != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintInternal(dAtA, i, uint64(m.Id))
	}
	if len(m.Group) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintInternal(dAtA, i, uint64(len(m.Group)))
		i += copy(dAtA[i:], m.Group)
	}
	if m.ReplicationFactor != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintInternal(dAtA, i, uint64(m.ReplicationFactor))
	}
	if len(m.Replicas) > 0 {
		for _, s := range m.Replicas {
			dAtA[i] = 0x32
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.Leader) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintInternal(dAtA, i, uint64(len(m.Leader)))
		i += copy(dAtA[i:], m.Leader)
	}
	if len(m.Isr) > 0 {
		for _, s := range m.Isr {
			dAtA[i] = 0x42
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.LeaderEpoch != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintInternal(dAtA, i, uint64(m.LeaderEpoch))
	}
	if m.Epoch != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintInternal(dAtA, i, uint64(m.Epoch))
	}
	if m.Paused {
		dAtA[i] = 0x58
		i++
		if m.Paused {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Readonly {
		dAtA[i] = 0x60
		i++
		if m.Readonly {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *RaftJoinRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RaftJoinRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.NodeID) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintInternal(dAtA, i, uint64(len(m.NodeID)))
		i += copy(dAtA[i:], m.NodeID)
	}
	if len(m.NodeAddr) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintInternal(dAtA, i, uint64(len(m.NodeAddr)))
		i += copy(dAtA[i:], m.NodeAddr)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *RaftJoinResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RaftJoinResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Error) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintInternal(dAtA, i, uint64(len(m.Error)))
		i += copy(dAtA[i:], m.Error)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *MetadataSnapshot) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MetadataSnapshot) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Streams) > 0 {
		for _, msg := range m.Streams {
			dAtA[i] = 0xa
			i++
			i = encodeVarintInternal(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ReplicationRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReplicationRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ReplicaID) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintInternal(dAtA, i, uint64(len(m.ReplicaID)))
		i += copy(dAtA[i:], m.ReplicaID)
	}
	if m.Offset != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintInternal(dAtA, i, uint64(m.Offset))
	}
	if m.LeaderEpoch != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintInternal(dAtA, i, uint64(m.LeaderEpoch))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *LeaderEpochOffsetRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LeaderEpochOffsetRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.LeaderEpoch != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintInternal(dAtA, i, uint64(m.LeaderEpoch))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *LeaderEpochOffsetResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LeaderEpochOffsetResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.EndOffset != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintInternal(dAtA, i, uint64(m.EndOffset))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *PropagatedRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PropagatedRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Op != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintInternal(dAtA, i, uint64(m.Op))
	}
	if m.CreateStreamOp != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintInternal(dAtA, i, uint64(m.CreateStreamOp.Size()))
		n30, err30 := m.CreateStreamOp.MarshalTo(dAtA[i:])
		if err30 != nil {
			return 0, err30
		}
		i += n30
	}
	if m.ShrinkISROp != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintInternal(dAtA, i, uint64(m.ShrinkISROp.Size()))
		n31, err31 := m.ShrinkISROp.MarshalTo(dAtA[i:])
		if err31 != nil {
			return 0, err31
		}
		i += n31
	}
	if m.ReportLeaderOp != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintInternal(dAtA, i, uint64(m.ReportLeaderOp.Size()))
		n32, err32 := m.ReportLeaderOp.MarshalTo(dAtA[i:])
		if err32 != nil {
			return 0, err32
		}
		i += n32
	}
	if m.ExpandISROp != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintInternal(dAtA, i, uint64(m.ExpandISROp.Size()))
		n33, err33 := m.ExpandISROp.MarshalTo(dAtA[i:])
		if err33 != nil {
			return 0, err33
		}
		i += n33
	}
	if m.DeleteStreamOp != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintInternal(dAtA, i, uint64(m.DeleteStreamOp.Size()))
		n34, err34 := m.DeleteStreamOp.MarshalTo(dAtA[i:])
		if err34 != nil {
			return 0, err34
		}
		i += n34
	}
	if m.PauseStreamOp != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintInternal(dAtA, i, uint64(m.PauseStreamOp.Size()))
		n35, err35 := m.PauseStreamOp.MarshalTo(dAtA[i:])
		if err35 != nil {
			return 0, err35
		}
		i += n35
	}
	if m.ResumeStreamOp != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintInternal(dAtA, i, uint64(m.ResumeStreamOp.Size()))
		n36, err36 := m.ResumeStreamOp.MarshalTo(dAtA[i:])
		if err36 != nil {
			return 0, err36
		}
		i += n36
	}
	if m.SetStreamReadonlyOp != nil {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintInternal(dAtA, i, uint64(m.SetStreamReadonlyOp.Size()))
		n37, err37 := m.SetStreamReadonlyOp.MarshalTo(dAtA[i:])
		if err37 != nil {
			return 0, err37
		}
		i += n37
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Error) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Error) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Code != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintInternal(dAtA, i, uint64(m.Code))
	}
	if len(m.Msg) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintInternal(dAtA, i, uint64(len(m.Msg)))
		i += copy(dAtA[i:], m.Msg)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *PropagatedResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PropagatedResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Op != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintInternal(dAtA, i, uint64(m.Op))
	}
	if m.Error != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintInternal(dAtA, i, uint64(m.Error.Size()))
		n38, err38 := m.Error.MarshalTo(dAtA[i:])
		if err38 != nil {
			return 0, err38
		}
		i += n38
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ServerInfoRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ServerInfoRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Id) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintInternal(dAtA, i, uint64(len(m.Id)))
		i += copy(dAtA[i:], m.Id)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ServerInfoResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ServerInfoResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Id) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintInternal(dAtA, i, uint64(len(m.Id)))
		i += copy(dAtA[i:], m.Id)
	}
	if len(m.Host) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintInternal(dAtA, i, uint64(len(m.Host)))
		i += copy(dAtA[i:], m.Host)
	}
	if m.Port != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintInternal(dAtA, i, uint64(m.Port))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *PartitionStatusRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PartitionStatusRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Stream) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintInternal(dAtA, i, uint64(len(m.Stream)))
		i += copy(dAtA[i:], m.Stream)
	}
	if m.Partition != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintInternal(dAtA, i, uint64(m.Partition))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *PartitionStatusResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PartitionStatusResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Exists {
		dAtA[i] = 0x8
		i++
		if m.Exists {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.IsLeader {
		dAtA[i] = 0x10
		i++
		if m.IsLeader {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *PartitionNotification) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PartitionNotification) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Stream) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintInternal(dAtA, i, uint64(len(m.Stream)))
		i += copy(dAtA[i:], m.Stream)
	}
	if m.Partition != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintInternal(dAtA, i, uint64(m.Partition))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Cursor) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Cursor) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Stream) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintInternal(dAtA, i, uint64(len(m.Stream)))
		i += copy(dAtA[i:], m.Stream)
	}
	if m.Partition != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintInternal(dAtA, i, uint64(m.Partition))
	}
	if len(m.CursorId) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintInternal(dAtA, i, uint64(len(m.CursorId)))
		i += copy(dAtA[i:], m.CursorId)
	}
	if m.Offset != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintInternal(dAtA, i, uint64(m.Offset))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func encodeVarintInternal(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *ServerState) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ServerID)
	if l > 0 {
		n += 1 + l + sovInternal(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RaftLog) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Op != 0 {
		n += 1 + sovInternal(uint64(m.Op))
	}
	if m.CreateStreamOp != nil {
		l = m.CreateStreamOp.Size()
		n += 1 + l + sovInternal(uint64(l))
	}
	if m.ShrinkISROp != nil {
		l = m.ShrinkISROp.Size()
		n += 1 + l + sovInternal(uint64(l))
	}
	if m.ChangeLeaderOp != nil {
		l = m.ChangeLeaderOp.Size()
		n += 1 + l + sovInternal(uint64(l))
	}
	if m.ExpandISROp != nil {
		l = m.ExpandISROp.Size()
		n += 1 + l + sovInternal(uint64(l))
	}
	if m.DeleteStreamOp != nil {
		l = m.DeleteStreamOp.Size()
		n += 1 + l + sovInternal(uint64(l))
	}
	if m.PauseStreamOp != nil {
		l = m.PauseStreamOp.Size()
		n += 1 + l + sovInternal(uint64(l))
	}
	if m.ResumeStreamOp != nil {
		l = m.ResumeStreamOp.Size()
		n += 1 + l + sovInternal(uint64(l))
	}
	if m.PublishActivityOp != nil {
		l = m.PublishActivityOp.Size()
		n += 1 + l + sovInternal(uint64(l))
	}
	if m.SetStreamReadonlyOp != nil {
		l = m.SetStreamReadonlyOp.Size()
		n += 1 + l + sovInternal(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CreateStreamOp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Stream != nil {
		l = m.Stream.Size()
		n += 1 + l + sovInternal(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ShrinkISROp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Stream)
	if l > 0 {
		n += 1 + l + sovInternal(uint64(l))
	}
	if m.Partition != 0 {
		n += 1 + sovInternal(uint64(m.Partition))
	}
	l = len(m.ReplicaToRemove)
	if l > 0 {
		n += 1 + l + sovInternal(uint64(l))
	}
	l = len(m.Leader)
	if l > 0 {
		n += 1 + l + sovInternal(uint64(l))
	}
	if m.LeaderEpoch != 0 {
		n += 1 + sovInternal(uint64(m.LeaderEpoch))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ExpandISROp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Stream)
	if l > 0 {
		n += 1 + l + sovInternal(uint64(l))
	}
	if m.Partition != 0 {
		n += 1 + sovInternal(uint64(m.Partition))
	}
	l = len(m.ReplicaToAdd)
	if l > 0 {
		n += 1 + l + sovInternal(uint64(l))
	}
	l = len(m.Leader)
	if l > 0 {
		n += 1 + l + sovInternal(uint64(l))
	}
	if m.LeaderEpoch != 0 {
		n += 1 + sovInternal(uint64(m.LeaderEpoch))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DeleteStreamOp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Stream)
	if l > 0 {
		n += 1 + l + sovInternal(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PauseStreamOp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Stream)
	if l > 0 {
		n += 1 + l + sovInternal(uint64(l))
	}
	if len(m.Partitions) > 0 {
		l = 0
		for _, e := range m.Partitions {
			l += sovInternal(uint64(e))
		}
		n += 1 + sovInternal(uint64(l)) + l
	}
	if m.ResumeAll {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ResumeStreamOp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Stream)
	if l > 0 {
		n += 1 + l + sovInternal(uint64(l))
	}
	if len(m.Partitions) > 0 {
		l = 0
		for _, e := range m.Partitions {
			l += sovInternal(uint64(e))
		}
		n += 1 + sovInternal(uint64(l)) + l
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ReportLeaderOp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Stream)
	if l > 0 {
		n += 1 + l + sovInternal(uint64(l))
	}
	if m.Partition != 0 {
		n += 1 + sovInternal(uint64(m.Partition))
	}
	l = len(m.Replica)
	if l > 0 {
		n += 1 + l + sovInternal(uint64(l))
	}
	l = len(m.Leader)
	if l > 0 {
		n += 1 + l + sovInternal(uint64(l))
	}
	if m.LeaderEpoch != 0 {
		n += 1 + sovInternal(uint64(m.LeaderEpoch))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ChangeLeaderOp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Stream)
	if l > 0 {
		n += 1 + l + sovInternal(uint64(l))
	}
	if m.Partition != 0 {
		n += 1 + sovInternal(uint64(m.Partition))
	}
	l = len(m.Leader)
	if l > 0 {
		n += 1 + l + sovInternal(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PublishActivityOp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RaftIndex != 0 {
		n += 1 + sovInternal(uint64(m.RaftIndex))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SetStreamReadonlyOp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Stream)
	if l > 0 {
		n += 1 + l + sovInternal(uint64(l))
	}
	if len(m.Partitions) > 0 {
		l = 0
		for _, e := range m.Partitions {
			l += sovInternal(uint64(e))
		}
		n += 1 + sovInternal(uint64(l)) + l
	}
	if m.Readonly {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *NullableInt64) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Value != 0 {
		n += 1 + sovInternal(uint64(m.Value))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *NullableInt32) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Value != 0 {
		n += 1 + sovInternal(uint64(m.Value))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *NullableBool) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Value {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *StreamConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RetentionMaxBytes != nil {
		l = m.RetentionMaxBytes.Size()
		n += 1 + l + sovInternal(uint64(l))
	}
	if m.RetentionMaxMessages != nil {
		l = m.RetentionMaxMessages.Size()
		n += 1 + l + sovInternal(uint64(l))
	}
	if m.RetentionMaxAge != nil {
		l = m.RetentionMaxAge.Size()
		n += 1 + l + sovInternal(uint64(l))
	}
	if m.CleanerInterval != nil {
		l = m.CleanerInterval.Size()
		n += 1 + l + sovInternal(uint64(l))
	}
	if m.SegmentMaxBytes != nil {
		l = m.SegmentMaxBytes.Size()
		n += 1 + l + sovInternal(uint64(l))
	}
	if m.SegmentMaxAge != nil {
		l = m.SegmentMaxAge.Size()
		n += 1 + l + sovInternal(uint64(l))
	}
	if m.CompactMaxGoroutines != nil {
		l = m.CompactMaxGoroutines.Size()
		n += 1 + l + sovInternal(uint64(l))
	}
	if m.CompactEnabled != nil {
		l = m.CompactEnabled.Size()
		n += 1 + l + sovInternal(uint64(l))
	}
	if m.AutoPauseTime != nil {
		l = m.AutoPauseTime.Size()
		n += 1 + l + sovInternal(uint64(l))
	}
	if m.AutoPauseDisableIfSubscribers != nil {
		l = m.AutoPauseDisableIfSubscribers.Size()
		n += 1 + l + sovInternal(uint64(l))
	}
	if m.MinIsr != nil {
		l = m.MinIsr.Size()
		n += 1 + l + sovInternal(uint64(l))
	}
	if m.OptimisticConcurrencyControl != nil {
		l = m.OptimisticConcurrencyControl.Size()
		n += 1 + l + sovInternal(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Stream) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovInternal(uint64(l))
	}
	l = len(m.Subject)
	if l > 0 {
		n += 1 + l + sovInternal(uint64(l))
	}
	if len(m.Partitions) > 0 {
		for _, e := range m.Partitions {
			l = e.Size()
			n += 1 + l + sovInternal(uint64(l))
		}
	}
	if m.Config != nil {
		l = m.Config.Size()
		n += 1 + l + sovInternal(uint64(l))
	}
	if m.CreationTimestamp != 0 {
		n += 1 + sovInternal(uint64(m.CreationTimestamp))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Partition) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Subject)
	if l > 0 {
		n += 1 + l + sovInternal(uint64(l))
	}
	l = len(m.Stream)
	if l > 0 {
		n += 1 + l + sovInternal(uint64(l))
	}
	if m.Id != 0 {
		n += 1 + sovInternal(uint64(m.Id))
	}
	l = len(m.Group)
	if l > 0 {
		n += 1 + l + sovInternal(uint64(l))
	}
	if m.ReplicationFactor != 0 {
		n += 1 + sovInternal(uint64(m.ReplicationFactor))
	}
	if len(m.Replicas) > 0 {
		for _, s := range m.Replicas {
			l = len(s)
			n += 1 + l + sovInternal(uint64(l))
		}
	}
	l = len(m.Leader)
	if l > 0 {
		n += 1 + l + sovInternal(uint64(l))
	}
	if len(m.Isr) > 0 {
		for _, s := range m.Isr {
			l = len(s)
			n += 1 + l + sovInternal(uint64(l))
		}
	}
	if m.LeaderEpoch != 0 {
		n += 1 + sovInternal(uint64(m.LeaderEpoch))
	}
	if m.Epoch != 0 {
		n += 1 + sovInternal(uint64(m.Epoch))
	}
	if m.Paused {
		n += 2
	}
	if m.Readonly {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RaftJoinRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.NodeID)
	if l > 0 {
		n += 1 + l + sovInternal(uint64(l))
	}
	l = len(m.NodeAddr)
	if l > 0 {
		n += 1 + l + sovInternal(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RaftJoinResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Error)
	if l > 0 {
		n += 1 + l + sovInternal(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MetadataSnapshot) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Streams) > 0 {
		for _, e := range m.Streams {
			l = e.Size()
			n += 1 + l + sovInternal(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ReplicationRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ReplicaID)
	if l > 0 {
		n += 1 + l + sovInternal(uint64(l))
	}
	if m.Offset != 0 {
		n += 1 + sovInternal(uint64(m.Offset))
	}
	if m.LeaderEpoch != 0 {
		n += 1 + sovInternal(uint64(m.LeaderEpoch))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LeaderEpochOffsetRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.LeaderEpoch != 0 {
		n += 1 + sovInternal(uint64(m.LeaderEpoch))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LeaderEpochOffsetResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.EndOffset != 0 {
		n += 1 + sovInternal(uint64(m.EndOffset))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PropagatedRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Op != 0 {
		n += 1 + sovInternal(uint64(m.Op))
	}
	if m.CreateStreamOp != nil {
		l = m.CreateStreamOp.Size()
		n += 1 + l + sovInternal(uint64(l))
	}
	if m.ShrinkISROp != nil {
		l = m.ShrinkISROp.Size()
		n += 1 + l + sovInternal(uint64(l))
	}
	if m.ReportLeaderOp != nil {
		l = m.ReportLeaderOp.Size()
		n += 1 + l + sovInternal(uint64(l))
	}
	if m.ExpandISROp != nil {
		l = m.ExpandISROp.Size()
		n += 1 + l + sovInternal(uint64(l))
	}
	if m.DeleteStreamOp != nil {
		l = m.DeleteStreamOp.Size()
		n += 1 + l + sovInternal(uint64(l))
	}
	if m.PauseStreamOp != nil {
		l = m.PauseStreamOp.Size()
		n += 1 + l + sovInternal(uint64(l))
	}
	if m.ResumeStreamOp != nil {
		l = m.ResumeStreamOp.Size()
		n += 1 + l + sovInternal(uint64(l))
	}
	if m.SetStreamReadonlyOp != nil {
		l = m.SetStreamReadonlyOp.Size()
		n += 1 + l + sovInternal(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Error) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovInternal(uint64(m.Code))
	}
	l = len(m.Msg)
	if l > 0 {
		n += 1 + l + sovInternal(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PropagatedResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Op != 0 {
		n += 1 + sovInternal(uint64(m.Op))
	}
	if m.Error != nil {
		l = m.Error.Size()
		n += 1 + l + sovInternal(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ServerInfoRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovInternal(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ServerInfoResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovInternal(uint64(l))
	}
	l = len(m.Host)
	if l > 0 {
		n += 1 + l + sovInternal(uint64(l))
	}
	if m.Port != 0 {
		n += 1 + sovInternal(uint64(m.Port))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PartitionStatusRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Stream)
	if l > 0 {
		n += 1 + l + sovInternal(uint64(l))
	}
	if m.Partition != 0 {
		n += 1 + sovInternal(uint64(m.Partition))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PartitionStatusResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Exists {
		n += 2
	}
	if m.IsLeader {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PartitionNotification) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Stream)
	if l > 0 {
		n += 1 + l + sovInternal(uint64(l))
	}
	if m.Partition != 0 {
		n += 1 + sovInternal(uint64(m.Partition))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Cursor) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Stream)
	if l > 0 {
		n += 1 + l + sovInternal(uint64(l))
	}
	if m.Partition != 0 {
		n += 1 + sovInternal(uint64(m.Partition))
	}
	l = len(m.CursorId)
	if l > 0 {
		n += 1 + l + sovInternal(uint64(l))
	}
	if m.Offset != 0 {
		n += 1 + sovInternal(uint64(m.Offset))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovInternal(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozInternal(x uint64) (n int) {
	return sovInternal(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *ServerState) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInternal
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ServerState: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ServerState: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInternal
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthInternal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ServerID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipInternal(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthInternal
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthInternal
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RaftLog) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInternal
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RaftLog: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RaftLog: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Op", wireType)
			}
			m.Op = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Op |= Op(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreateStreamOp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInternal
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthInternal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CreateStreamOp == nil {
				m.CreateStreamOp = &CreateStreamOp{}
			}
			if err := m.CreateStreamOp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShrinkISROp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInternal
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthInternal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ShrinkISROp == nil {
				m.ShrinkISROp = &ShrinkISROp{}
			}
			if err := m.ShrinkISROp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChangeLeaderOp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInternal
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthInternal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ChangeLeaderOp == nil {
				m.ChangeLeaderOp = &ChangeLeaderOp{}
			}
			if err := m.ChangeLeaderOp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpandISROp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInternal
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthInternal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ExpandISROp == nil {
				m.ExpandISROp = &ExpandISROp{}
			}
			if err := m.ExpandISROp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeleteStreamOp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInternal
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthInternal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DeleteStreamOp == nil {
				m.DeleteStreamOp = &DeleteStreamOp{}
			}
			if err := m.DeleteStreamOp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PauseStreamOp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInternal
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthInternal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PauseStreamOp == nil {
				m.PauseStreamOp = &PauseStreamOp{}
			}
			if err := m.PauseStreamOp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResumeStreamOp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInternal
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthInternal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ResumeStreamOp == nil {
				m.ResumeStreamOp = &ResumeStreamOp{}
			}
			if err := m.ResumeStreamOp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PublishActivityOp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInternal
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthInternal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PublishActivityOp == nil {
				m.PublishActivityOp = &PublishActivityOp{}
			}
			if err := m.PublishActivityOp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SetStreamReadonlyOp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInternal
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthInternal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SetStreamReadonlyOp == nil {
				m.SetStreamReadonlyOp = &SetStreamReadonlyOp{}
			}
			if err := m.SetStreamReadonlyOp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipInternal(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthInternal
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthInternal
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateStreamOp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInternal
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateStreamOp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateStreamOp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stream", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInternal
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthInternal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Stream == nil {
				m.Stream = &Stream{}
			}
			if err := m.Stream.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipInternal(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthInternal
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthInternal
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ShrinkISROp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInternal
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ShrinkISROp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ShrinkISROp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stream", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInternal
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthInternal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Stream = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Partition", wireType)
			}
			m.Partition = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Partition |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplicaToRemove", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInternal
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthInternal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReplicaToRemove = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Leader", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInternal
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthInternal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Leader = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LeaderEpoch", wireType)
			}
			m.LeaderEpoch = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LeaderEpoch |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipInternal(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthInternal
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthInternal
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ExpandISROp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInternal
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ExpandISROp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ExpandISROp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stream", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInternal
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthInternal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Stream = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Partition", wireType)
			}
			m.Partition = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Partition |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplicaToAdd", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInternal
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthInternal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReplicaToAdd = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Leader", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInternal
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthInternal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Leader = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LeaderEpoch", wireType)
			}
			m.LeaderEpoch = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LeaderEpoch |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipInternal(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthInternal
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthInternal
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeleteStreamOp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInternal
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeleteStreamOp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeleteStreamOp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stream", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInternal
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthInternal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Stream = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipInternal(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthInternal
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthInternal
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PauseStreamOp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInternal
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PauseStreamOp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PauseStreamOp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stream", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInternal
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthInternal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Stream = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowInternal
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Partitions = append(m.Partitions, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowInternal
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthInternal
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthInternal
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Partitions) == 0 {
					m.Partitions = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowInternal
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Partitions = append(m.Partitions, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Partitions", wireType)
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResumeAll", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ResumeAll = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipInternal(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthInternal
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthInternal
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ResumeStreamOp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInternal
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ResumeStreamOp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ResumeStreamOp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stream", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInternal
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthInternal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Stream = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowInternal
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Partitions = append(m.Partitions, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowInternal
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthInternal
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthInternal
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Partitions) == 0 {
					m.Partitions = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowInternal
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Partitions = append(m.Partitions, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Partitions", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipInternal(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthInternal
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthInternal
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReportLeaderOp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInternal
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReportLeaderOp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReportLeaderOp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stream", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInternal
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthInternal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Stream = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Partition", wireType)
			}
			m.Partition = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Partition |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Replica", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInternal
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthInternal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Replica = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Leader", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInternal
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthInternal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Leader = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LeaderEpoch", wireType)
			}
			m.LeaderEpoch = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LeaderEpoch |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipInternal(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthInternal
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthInternal
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ChangeLeaderOp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInternal
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ChangeLeaderOp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ChangeLeaderOp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stream", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInternal
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthInternal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Stream = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Partition", wireType)
			}
			m.Partition = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Partition |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Leader", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInternal
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthInternal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Leader = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipInternal(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthInternal
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthInternal
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PublishActivityOp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInternal
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PublishActivityOp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PublishActivityOp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RaftIndex", wireType)
			}
			m.RaftIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RaftIndex |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipInternal(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthInternal
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthInternal
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SetStreamReadonlyOp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInternal
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SetStreamReadonlyOp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SetStreamReadonlyOp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stream", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInternal
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthInternal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Stream = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowInternal
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Partitions = append(m.Partitions, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowInternal
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthInternal
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthInternal
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Partitions) == 0 {
					m.Partitions = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowInternal
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Partitions = append(m.Partitions, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Partitions", wireType)
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Readonly", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Readonly = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipInternal(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthInternal
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthInternal
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NullableInt64) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInternal
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NullableInt64: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NullableInt64: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			m.Value = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Value |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipInternal(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthInternal
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthInternal
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NullableInt32) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInternal
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NullableInt32: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NullableInt32: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			m.Value = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Value |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipInternal(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthInternal
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthInternal
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NullableBool) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInternal
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NullableBool: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NullableBool: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Value = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipInternal(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthInternal
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthInternal
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StreamConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInternal
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StreamConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StreamConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RetentionMaxBytes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInternal
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthInternal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RetentionMaxBytes == nil {
				m.RetentionMaxBytes = &NullableInt64{}
			}
			if err := m.RetentionMaxBytes.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RetentionMaxMessages", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInternal
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthInternal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RetentionMaxMessages == nil {
				m.RetentionMaxMessages = &NullableInt64{}
			}
			if err := m.RetentionMaxMessages.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RetentionMaxAge", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInternal
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthInternal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RetentionMaxAge == nil {
				m.RetentionMaxAge = &NullableInt64{}
			}
			if err := m.RetentionMaxAge.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CleanerInterval", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInternal
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthInternal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CleanerInterval == nil {
				m.CleanerInterval = &NullableInt64{}
			}
			if err := m.CleanerInterval.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SegmentMaxBytes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInternal
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthInternal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SegmentMaxBytes == nil {
				m.SegmentMaxBytes = &NullableInt64{}
			}
			if err := m.SegmentMaxBytes.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SegmentMaxAge", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInternal
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthInternal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SegmentMaxAge == nil {
				m.SegmentMaxAge = &NullableInt64{}
			}
			if err := m.SegmentMaxAge.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CompactMaxGoroutines", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInternal
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthInternal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CompactMaxGoroutines == nil {
				m.CompactMaxGoroutines = &NullableInt32{}
			}
			if err := m.CompactMaxGoroutines.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CompactEnabled", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInternal
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthInternal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CompactEnabled == nil {
				m.CompactEnabled = &NullableBool{}
			}
			if err := m.CompactEnabled.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AutoPauseTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInternal
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthInternal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AutoPauseTime == nil {
				m.AutoPauseTime = &NullableInt64{}
			}
			if err := m.AutoPauseTime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AutoPauseDisableIfSubscribers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInternal
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthInternal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AutoPauseDisableIfSubscribers == nil {
				m.AutoPauseDisableIfSubscribers = &NullableBool{}
			}
			if err := m.AutoPauseDisableIfSubscribers.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinIsr", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInternal
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthInternal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MinIsr == nil {
				m.MinIsr = &NullableInt32{}
			}
			if err := m.MinIsr.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OptimisticConcurrencyControl", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInternal
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthInternal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OptimisticConcurrencyControl == nil {
				m.OptimisticConcurrencyControl = &NullableBool{}
			}
			if err := m.OptimisticConcurrencyControl.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipInternal(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthInternal
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthInternal
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Stream) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInternal
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Stream: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Stream: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInternal
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthInternal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Subject", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInternal
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthInternal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Subject = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Partitions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInternal
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthInternal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Partitions = append(m.Partitions, &Partition{})
			if err := m.Partitions[len(m.Partitions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Config", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInternal
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthInternal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Config == nil {
				m.Config = &StreamConfig{}
			}
			if err := m.Config.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreationTimestamp", wireType)
			}
			m.CreationTimestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CreationTimestamp |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipInternal(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthInternal
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthInternal
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Partition) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInternal
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Partition: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Partition: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Subject", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInternal
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthInternal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Subject = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stream", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInternal
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthInternal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Stream = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Group", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInternal
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthInternal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Group = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplicationFactor", wireType)
			}
			m.ReplicationFactor = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReplicationFactor |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Replicas", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInternal
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthInternal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Replicas = append(m.Replicas, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Leader", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInternal
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthInternal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Leader = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Isr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInternal
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthInternal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Isr = append(m.Isr, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LeaderEpoch", wireType)
			}
			m.LeaderEpoch = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LeaderEpoch |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Epoch", wireType)
			}
			m.Epoch = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Epoch |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Paused", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Paused = bool(v != 0)
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Readonly", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Readonly = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipInternal(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthInternal
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthInternal
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RaftJoinRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInternal
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RaftJoinRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RaftJoinRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInternal
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthInternal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NodeID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeAddr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInternal
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthInternal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NodeAddr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipInternal(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthInternal
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthInternal
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RaftJoinResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInternal
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RaftJoinResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RaftJoinResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInternal
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthInternal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Error = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipInternal(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthInternal
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthInternal
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MetadataSnapshot) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInternal
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MetadataSnapshot: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MetadataSnapshot: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Streams", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInternal
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthInternal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Streams = append(m.Streams, &Stream{})
			if err := m.Streams[len(m.Streams)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipInternal(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthInternal
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthInternal
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReplicationRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInternal
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReplicationRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReplicationRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplicaID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInternal
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthInternal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReplicaID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Offset", wireType)
			}
			m.Offset = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Offset |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LeaderEpoch", wireType)
			}
			m.LeaderEpoch = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LeaderEpoch |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipInternal(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthInternal
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthInternal
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LeaderEpochOffsetRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInternal
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LeaderEpochOffsetRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LeaderEpochOffsetRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LeaderEpoch", wireType)
			}
			m.LeaderEpoch = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LeaderEpoch |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipInternal(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthInternal
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthInternal
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LeaderEpochOffsetResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInternal
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LeaderEpochOffsetResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LeaderEpochOffsetResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndOffset", wireType)
			}
			m.EndOffset = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EndOffset |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipInternal(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthInternal
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthInternal
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PropagatedRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInternal
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PropagatedRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PropagatedRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Op", wireType)
			}
			m.Op = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Op |= Op(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreateStreamOp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInternal
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthInternal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CreateStreamOp == nil {
				m.CreateStreamOp = &CreateStreamOp{}
			}
			if err := m.CreateStreamOp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShrinkISROp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInternal
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthInternal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ShrinkISROp == nil {
				m.ShrinkISROp = &ShrinkISROp{}
			}
			if err := m.ShrinkISROp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReportLeaderOp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInternal
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthInternal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ReportLeaderOp == nil {
				m.ReportLeaderOp = &ReportLeaderOp{}
			}
			if err := m.ReportLeaderOp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpandISROp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInternal
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthInternal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ExpandISROp == nil {
				m.ExpandISROp = &ExpandISROp{}
			}
			if err := m.ExpandISROp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeleteStreamOp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInternal
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthInternal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DeleteStreamOp == nil {
				m.DeleteStreamOp = &DeleteStreamOp{}
			}
			if err := m.DeleteStreamOp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PauseStreamOp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInternal
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthInternal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PauseStreamOp == nil {
				m.PauseStreamOp = &PauseStreamOp{}
			}
			if err := m.PauseStreamOp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResumeStreamOp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInternal
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthInternal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ResumeStreamOp == nil {
				m.ResumeStreamOp = &ResumeStreamOp{}
			}
			if err := m.ResumeStreamOp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SetStreamReadonlyOp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInternal
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthInternal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SetStreamReadonlyOp == nil {
				m.SetStreamReadonlyOp = &SetStreamReadonlyOp{}
			}
			if err := m.SetStreamReadonlyOp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipInternal(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthInternal
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthInternal
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Error) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInternal
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Error: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Error: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Msg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInternal
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthInternal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Msg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipInternal(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthInternal
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthInternal
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PropagatedResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInternal
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PropagatedResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PropagatedResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Op", wireType)
			}
			m.Op = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Op |= Op(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInternal
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthInternal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Error == nil {
				m.Error = &Error{}
			}
			if err := m.Error.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipInternal(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthInternal
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthInternal
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ServerInfoRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInternal
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ServerInfoRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ServerInfoRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInternal
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthInternal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipInternal(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthInternal
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthInternal
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ServerInfoResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInternal
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ServerInfoResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ServerInfoResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInternal
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthInternal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Host", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInternal
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthInternal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Host = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Port", wireType)
			}
			m.Port = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Port |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipInternal(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthInternal
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthInternal
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PartitionStatusRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInternal
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PartitionStatusRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PartitionStatusRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stream", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInternal
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthInternal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Stream = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Partition", wireType)
			}
			m.Partition = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Partition |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipInternal(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthInternal
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthInternal
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PartitionStatusResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInternal
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PartitionStatusResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PartitionStatusResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Exists", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Exists = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsLeader", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsLeader = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipInternal(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthInternal
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthInternal
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PartitionNotification) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInternal
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PartitionNotification: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PartitionNotification: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stream", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInternal
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthInternal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Stream = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Partition", wireType)
			}
			m.Partition = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Partition |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipInternal(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthInternal
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthInternal
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Cursor) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInternal
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Cursor: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Cursor: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stream", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInternal
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthInternal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Stream = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Partition", wireType)
			}
			m.Partition = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Partition |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CursorId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInternal
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthInternal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CursorId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Offset", wireType)
			}
			m.Offset = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Offset |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipInternal(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthInternal
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthInternal
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipInternal(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowInternal
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthInternal
			}
			iNdEx += length
			if iNdEx < 0 {
				return 0, ErrInvalidLengthInternal
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowInternal
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipInternal(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
				if iNdEx < 0 {
					return 0, ErrInvalidLengthInternal
				}
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthInternal = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowInternal   = fmt.Errorf("proto: integer overflow")
)
